(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{418:function(v,_,t){"use strict";t.r(_);var s=t(52),e=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"跨标签页通讯"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#跨标签页通讯"}},[v._v("#")]),v._v(" 跨标签页通讯")]),v._v(" "),t("p",[v._v("不同标签页间的通讯，本质原理就是去运用一些可以 "),t("strong",[v._v("共享的中间介质")]),v._v("，因此比较常用的有以下方法:")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("通过父页面 "),t("code",[v._v("window.open()")]),v._v(" 和子页面 "),t("code",[v._v("postMessage")])]),v._v(" "),t("ul",[t("li",[v._v("异步下，通过 "),t("code",[v._v("window.open('about: blank')")]),v._v(" 和 "),t("code",[v._v("tab.location.href = '*'")])])])]),v._v(" "),t("li",[t("p",[v._v("设置同域下共享的 "),t("code",[v._v("localStorage")]),v._v(" 与监听 "),t("code",[v._v("window.onstorage")])]),v._v(" "),t("ul",[t("li",[v._v("重复写入相同的值无法触发")]),v._v(" "),t("li",[v._v("会受到浏览器隐身模式等的限制")])])]),v._v(" "),t("li",[t("p",[v._v("设置共享 "),t("code",[v._v("cookie")]),v._v(" 与不断轮询脏检查( "),t("code",[v._v("setInterval")]),v._v(" )")])]),v._v(" "),t("li",[t("p",[v._v("借助服务端或者中间层实现")])])]),v._v(" "),t("h2",{attrs:{id:"浏览器架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器架构"}},[v._v("#")]),v._v(" 浏览器架构")]),v._v(" "),t("ul",[t("li",[v._v("用户界面")]),v._v(" "),t("li",[v._v("Browser 进程")]),v._v(" "),t("li",[v._v("第三方插件进程 （每种类型的插件对应一个进程，当使用该插件时才创建）")]),v._v(" "),t("li",[v._v("GPU 进程 （该进程也只有一个，用于 3D 绘制等等）")]),v._v(" "),t("li",[v._v("内核（渲染进程 Renderer）\n"),t("ul",[t("li",[v._v("GUI 渲染线程")]),v._v(" "),t("li",[v._v("JS 引擎线程\n"),t("ul",[t("li",[v._v("执行栈")])])]),v._v(" "),t("li",[v._v("事件触发线程\n"),t("ul",[t("li",[v._v("消息队列\n"),t("ul",[t("li",[v._v("微任务")]),v._v(" "),t("li",[v._v("宏任务")])])])])]),v._v(" "),t("li",[v._v("异步 HTTP 线程")]),v._v(" "),t("li",[v._v("定时器线程")])])])]),v._v(" "),t("h2",{attrs:{id:"事件循环-event-loop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件循环-event-loop"}},[v._v("#")]),v._v(" 事件循环(Event Loop)")]),v._v(" "),t("p",[v._v("事件循环是指: JS 引擎线程只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的事件循环(Event Loop)")]),v._v(" "),t("ul",[t("li",[v._v("宏任务 "),t("code",[v._v("macrotask(task)")]),v._v(":\n"),t("ul",[t("li",[v._v("主代码块")]),v._v(" "),t("li",[v._v("setTimeout")]),v._v(" "),t("li",[v._v("setInterval")]),v._v(" "),t("li",[v._v("setImmediate - Node")]),v._v(" "),t("li",[v._v("requestAnimationFrame - 浏览器")])])]),v._v(" "),t("li",[v._v("微任务 "),t("code",[v._v("microtask(jobs)")]),v._v(":\n"),t("ul",[t("li",[v._v("process.nextTick () - Node")]),v._v(" "),t("li",[v._v("Promise.then()")]),v._v(" "),t("li",[v._v("catch")]),v._v(" "),t("li",[v._v("finally")]),v._v(" "),t("li",[v._v("Object.observe")]),v._v(" "),t("li",[v._v("MutationObserver")])])])]),v._v(" "),t("h2",{attrs:{id:"从输入-url-到展示的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从输入-url-到展示的过程"}},[v._v("#")]),v._v(" 从输入 url 到展示的过程")]),v._v(" "),t("ul",[t("li",[v._v("查找缓存")]),v._v(" "),t("li",[v._v("DNS 解析")]),v._v(" "),t("li",[v._v("TCP 三次握手")]),v._v(" "),t("li",[v._v("发送请求，分析 url，设置请求报文(头，主体)")]),v._v(" "),t("li",[v._v("服务器返回请求的文件 (html)")]),v._v(" "),t("li",[v._v("关闭 TCP 连接：通过四次挥手释放 TCP 连接")]),v._v(" "),t("li",[v._v("浏览器渲染\n"),t("ul",[t("li",[v._v("HTML parser --\x3e DOM Tree\n"),t("ul",[t("li",[v._v("标记化算法，进行元素状态的标记")]),v._v(" "),t("li",[v._v("dom 树构建")])])]),v._v(" "),t("li",[v._v("CSS parser --\x3e Style Tree\n"),t("ul",[t("li",[v._v("解析 css 代码，生成样式树")])])]),v._v(" "),t("li",[v._v("attachment --\x3e Render Tree\n"),t("ul",[t("li",[v._v("结合 dom 树 与 style 树，生成渲染树")])])]),v._v(" "),t("li",[v._v("layout: 布局")]),v._v(" "),t("li",[v._v("GPU painting: 像素绘制页面")])])])]),v._v(" "),t("h2",{attrs:{id:"重绘与回流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重绘与回流"}},[v._v("#")]),v._v(" 重绘与回流")]),v._v(" "),t("p",[v._v("当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("重绘(repaint)")]),v._v(": 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此 "),t("strong",[v._v("损耗较少")])]),v._v(" "),t("li",[t("strong",[v._v("回流(reflow)")]),v._v(": 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:\n"),t("ul",[t("li",[v._v("页面初次渲染")]),v._v(" "),t("li",[v._v("浏览器窗口大小改变")]),v._v(" "),t("li",[v._v("元素尺寸、位置、内容发生改变")]),v._v(" "),t("li",[v._v("元素字体大小变化")]),v._v(" "),t("li",[v._v("添加或者删除可见的 dom 元素")]),v._v(" "),t("li",[v._v("激活 CSS 伪类（例如：:hover）")]),v._v(" "),t("li",[v._v("查询某些属性或调用某些方法\n"),t("ul",[t("li",[v._v("clientWidth、clientHeight、clientTop、clientLeft")]),v._v(" "),t("li",[v._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),v._v(" "),t("li",[v._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),v._v(" "),t("li",[v._v("getComputedStyle()")]),v._v(" "),t("li",[v._v("getBoundingClientRect()")]),v._v(" "),t("li",[v._v("scrollTo()")])])])])])]),v._v(" "),t("p",[v._v("回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。")]),v._v(" "),t("h2",{attrs:{id:"存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#存储"}},[v._v("#")]),v._v(" 存储")]),v._v(" "),t("p",[v._v("我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。")]),v._v(" "),t("ul",[t("li",[v._v("短暂性的时候，我们只需要将数据存在内存中，只在运行时可用")]),v._v(" "),t("li",[v._v("持久性存储，可以分为 浏览器端 与 服务器端\n"),t("ul",[t("li",[v._v("浏览器:\n"),t("ul",[t("li",[t("code",[v._v("cookie")]),v._v(": 通常用于存储用户身份，登录状态等\n"),t("ul",[t("li",[t("code",[v._v("http")]),v._v(" 中自动携带， 体积上限为 4K， 可自行设置过期时间")])])]),v._v(" "),t("li",[t("code",[v._v("localStorage / sessionStorage")]),v._v(": 长久储存/窗口关闭删除， 体积限制为 4~5M")]),v._v(" "),t("li",[t("code",[v._v("indexDB")])])])]),v._v(" "),t("li",[v._v("服务器:\n"),t("ul",[t("li",[v._v("分布式缓存 redis")]),v._v(" "),t("li",[v._v("数据库")])])])])])]),v._v(" "),t("h2",{attrs:{id:"web-worker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#web-worker"}},[v._v("#")]),v._v(" Web Worker")]),v._v(" "),t("p",[v._v("现代浏览器为 "),t("code",[v._v("JavaScript")]),v._v(" 创造的 "),t("strong",[v._v("多线程环境")]),v._v("。可以新建并将部分任务分配到 "),t("code",[v._v("worker")]),v._v(" 线程并行运行，两个线程可 "),t("strong",[v._v("独立运行，互不干扰")]),v._v("，可通过自带的 "),t("strong",[v._v("消息机制")]),v._v(" 相互通信。")]),v._v(" "),t("h4",{attrs:{id:"基本用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[v._v("#")]),v._v(" 基本用法:")]),v._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 创建 worker")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("const")]),v._v(" worker "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Worker")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v("'work.js'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 向 worker 线程推送消息")]),v._v("\nworker"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("postMessage")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v("'Hello World'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 监听 worker 线程发送过来的消息")]),v._v("\nworker"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[v._v("onmessage")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("function")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[v._v("event")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n  console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v("'Received message '")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("+")]),v._v(" event"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("data"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])]),t("h4",{attrs:{id:"限制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#限制"}},[v._v("#")]),v._v(" 限制:")]),v._v(" "),t("ul",[t("li",[v._v("同源限制")]),v._v(" "),t("li",[v._v("无法使用 "),t("code",[v._v("document")]),v._v(" / "),t("code",[v._v("window")]),v._v(" / "),t("code",[v._v("alert")]),v._v(" / "),t("code",[v._v("confirm")])]),v._v(" "),t("li",[v._v("无法加载本地资源")])]),v._v(" "),t("h2",{attrs:{id:"v8-垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8-垃圾回收机制"}},[v._v("#")]),v._v(" V8 垃圾回收机制")]),v._v(" "),t("p",[v._v("V8 的垃圾回收策略主要基于 "),t("strong",[v._v("分代式垃圾回收机制")]),v._v("，根据根据"),t("strong",[v._v("对象的存活时间")]),v._v("将内存的垃圾回收进行不同的分代，然后根据不同的分代采用不同的垃圾回收算法，其主要分成 "),t("strong",[v._v("新生代空间")]),v._v(" 和 "),t("strong",[v._v("老生代空间")]),v._v("。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("新生代空间")]),v._v(": 用于存活较短的对象\n"),t("ul",[t("li",[v._v("又分成两个空间: from 空间 与 to 空间")]),v._v(" "),t("li",[v._v("Scavenge GC 算法: 当 from 空间被占满时，启动 GC 算法\n"),t("ul",[t("li",[v._v("存活的对象从 from space 转移到 to space")]),v._v(" "),t("li",[v._v("清空 from space")]),v._v(" "),t("li",[v._v("from space 与 to space 互换")]),v._v(" "),t("li",[v._v("完成一次新生代 GC")])])])])]),v._v(" "),t("li",[t("strong",[v._v("老生代空间")]),v._v(": 用于存活时间较长的对象\n"),t("ul",[t("li",[v._v("从 新生代空间 转移到 老生代空间 的条件\n"),t("ul",[t("li",[v._v("经历过一次以上 Scavenge GC 的对象")]),v._v(" "),t("li",[v._v("当 to space 体积超过 25%")])])]),v._v(" "),t("li",[t("strong",[v._v("标记清除")]),v._v(": 标记存活的对象，未被标记的则被释放")]),v._v(" "),t("li",[t("strong",[v._v("标记整理")]),v._v(": 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 "),t("strong",[v._v("内存的碎片化")])]),v._v(" "),t("li",[t("strong",[v._v("增量标记与惰性清理")])]),v._v(" "),t("li",[t("strong",[v._v("并发回收")])])])])]),v._v(" "),t("h2",{attrs:{id:"内存泄露"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存泄露"}},[v._v("#")]),v._v(" 内存泄露")]),v._v(" "),t("ul",[t("li",[v._v("意外的"),t("strong",[v._v("全局变量")]),v._v(": 无法被回收")]),v._v(" "),t("li",[t("strong",[v._v("定时器")]),v._v(": 未被正确关闭，导致所引用的外部变量无法被释放")]),v._v(" "),t("li",[t("strong",[v._v("事件监听")]),v._v(": 没有正确销毁 (低版本浏览器可能出现)")]),v._v(" "),t("li",[t("strong",[v._v("闭包")]),v._v(": 会导致父级中的变量无法被释放")]),v._v(" "),t("li",[t("strong",[v._v("dom 引用")]),v._v(": dom 元素被删除时，内存中的引用未被正确清空")])])])}),[],!1,null,null,null);_.default=e.exports}}]);