(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{417:function(v,_,l){"use strict";l.r(_);var e=l(52),i=Object(e.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"css-盒模型"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#css-盒模型"}},[v._v("#")]),v._v(" CSS 盒模型")]),v._v(" "),l("p",[v._v("CSS 盒模型由四部分组成：")]),v._v(" "),l("ul",[l("li",[v._v("内容边界 Content")]),v._v(" "),l("li",[v._v("内边距边界 Padding")]),v._v(" "),l("li",[v._v("边框边界 Border")]),v._v(" "),l("li",[v._v("外边框边界 Margin")])]),v._v(" "),l("img",{attrs:{src:v.$withBase("/assets/box_model.gif"),alt:"foo"}}),v._v(" "),l("p",[v._v("盒模型的类型可通过 box-sizing 进行设置。根据计算宽高的区域可分为：")]),v._v(" "),l("ul",[l("li",[v._v("content-box (W3C 标准盒模型)")]),v._v(" "),l("li",[v._v("border-box (IE 盒模型)")]),v._v(" "),l("li",[v._v("padding-box (FireFox 曾经支持)")]),v._v(" "),l("li",[v._v("margin-box (浏览器未实现)")])]),v._v(" "),l("div",{staticClass:"custom-block warning"},[l("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),l("p",[v._v("理论上是有上面 4 种盒子，但现在 w3c 与 mdn 规范中均只支持 content-box 与 border-box；")])]),v._v(" "),l("h2",{attrs:{id:"position"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#position"}},[v._v("#")]),v._v(" position")]),v._v(" "),l("p",[v._v("CSS position 属性用于指定一个元素在文档中的定位方式。")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("static")]),v._v(" "),l("ul",[l("li",[v._v("默认，即元素在文档常规流中当前的布局位置。")])])]),v._v(" "),l("li",[l("p",[v._v("relative")]),v._v(" "),l("ul",[l("li",[v._v("相对定位，相对于其正常位置进行定位。")]),v._v(" "),l("li",[v._v("未脱离文档流。")])])]),v._v(" "),l("li",[l("p",[v._v("absolute")]),v._v(" "),l("ul",[l("li",[v._v("绝对定位，相对于 static 定位以外的第一个父元素进行定位。")]),v._v(" "),l("li",[v._v("脱离文档流。")])])]),v._v(" "),l("li",[l("p",[v._v("fixed")]),v._v(" "),l("ul",[l("li",[v._v("固定定位，相对于浏览器窗口进行定位。")]),v._v(" "),l("li",[v._v("脱离文档流.")]),v._v(" "),l("li",[l("code",[v._v("fixed")]),v._v(" 属性会创建新的层叠上下文。当元素祖先的 "),l("code",[v._v("transform")]),v._v(", "),l("code",[v._v("perspective")]),v._v(" 或 "),l("code",[v._v("filter")]),v._v(" 属性非 "),l("code",[v._v("none")]),v._v(" 时，容器由视口改为该祖先。")])])]),v._v(" "),l("li",[l("p",[v._v("sticky")]),v._v(" "),l("ul",[l("li",[v._v("粘性定位，该值总是创建一个新的层叠上下文（stacking context）,该定位基于用户滚动的位置。它的行为就像 "),l("code",[v._v("position:relative")]),v._v("; 而当页面滚动超出目标区域时，它的表现就像 "),l("code",[v._v("position:fixed")]),v._v(";，它会固定在目标位置。")])])])]),v._v(" "),l("h2",{attrs:{id:"flex"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#flex"}},[v._v("#")]),v._v(" flex")]),v._v(" "),l("img",{attrs:{src:v.$withBase("/assets/flex.png"),alt:"foo"}}),v._v(" "),l("p",[v._v("在 flex 容器中默认存在两条轴，水平主轴(main axis)和垂直的交叉轴(cross axis)，在容器中每个单元被称之为 flex item。")]),v._v(" "),l("ul",[l("li",[l("code",[v._v("display: flex | inline-flex")])])]),v._v(" "),l("div",{staticClass:"custom-block warning"},[l("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),l("p",[v._v("当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。")])]),v._v(" "),l("h4",{attrs:{id:"容器属性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#容器属性"}},[v._v("#")]),v._v(" 容器属性")]),v._v(" "),l("ul",[l("li",[l("code",[v._v("flex-direction: row | row-reverse | column | column-reverse;")]),v._v(" (决定主轴方向)")]),v._v(" "),l("li",[l("code",[v._v("flex-wrap: nowrap | wrap | wrap-reverse;")]),v._v("（决定容器内项目是否可换行）")]),v._v(" "),l("li",[l("code",[v._v("flex-flow: <flex-direction> || <flex-wrap>;")]),v._v("（flex-direction 和 flex-wrap 的简写形式）")]),v._v(" "),l("li",[l("code",[v._v("justify-content: flex-start | flex-end | center | space-between | space-around;")]),v._v(" (定义了项目在主轴的对齐方式)")]),v._v(" "),l("li",[l("code",[v._v("align-items: flex-start | flex-end | center | baseline | stretch;")]),v._v(" (定义了项目在交叉轴上的对齐方式)")]),v._v(" "),l("li",[l("code",[v._v("align-content: flex-start | flex-end | center | space-between | space-around | stretch;")]),v._v(" (定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用)")])]),v._v(" "),l("h4",{attrs:{id:"flex-item-属性"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#flex-item-属性"}},[v._v("#")]),v._v(" flex item 属性")]),v._v(" "),l("ul",[l("li",[l("code",[v._v("order: <integer>;")]),v._v(" (定义项目在容器中的排列顺序)")]),v._v(" "),l("li",[l("code",[v._v("flex-basis: <length> | auto;")]),v._v(" (指定 flex 元素在主轴方向上的初始大小（基础尺寸）,默认值为 auto，即项目本身大小)")]),v._v(" "),l("li",[l("code",[v._v("flex-grow: <number>;")]),v._v(" （定义项目的放大比例，默认值为 0）")]),v._v(" "),l("li",[l("code",[v._v("flex-shrink: <number>;")]),v._v(" (定义了项目的缩小比例，默认值为 1)")]),v._v(" "),l("li",[l("code",[v._v("flex: none | auto | [< 'flex-grow' > < 'flex-shrink' >? || < 'flex-basis' > ];")]),v._v(" （flex-grow, flex-shrink 和 flex-basis的简写）\n"),l("ul",[l("li",[v._v("flex 默认值为 0 1 auto")]),v._v(" "),l("li",[v._v("flex: none，等同于 flex: 0 0 auto;")]),v._v(" "),l("li",[v._v("flex: auto，等同于 flex: 1 1 auto;")]),v._v(" "),l("li",[v._v("flex: 1，等同于 flex: 1 1 0%;")]),v._v(" "),l("li",[v._v("flex: 0，等同于 flex 0 1 0%;")])])]),v._v(" "),l("li",[l("code",[v._v("align-self: auto | flex-start | flex-end | center | baseline | stretch;")]),v._v(" (允许单个项目有与其他项目不一样的对齐方式)")])]),v._v(" "),l("h2",{attrs:{id:"层叠上下文"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#层叠上下文"}},[v._v("#")]),v._v(" 层叠上下文")]),v._v(" "),l("p",[v._v("层叠上下文(stacking context)，是 HTML 中一个三维的概念。在 CSS2.1 规范中，每个盒模型的位置是三维的，分别是平面画布上的 X 轴，Y 轴以及表示层叠的 Z 轴。")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("层叠上下文的创建:")]),v._v(" "),l("ul",[l("li",[l("html"),v._v("本身就具有层叠上下文，称为“根层叠上下文”。\n")]),v._v(" "),l("li",[v._v("普通元素设置 "),l("code",[v._v("position")]),v._v(" 为非 "),l("code",[v._v("static")]),v._v(" 值并设置 "),l("code",[v._v("z-index")]),v._v(" 属性为具体数值，产生层叠上下文。")]),v._v(" "),l("li",[v._v("CSS3 中的新属性也可以产生层叠上下文:\n"),l("ul",[l("li",[l("code",[v._v("flex")])]),v._v(" "),l("li",[l("code",[v._v("transform")])]),v._v(" "),l("li",[l("code",[v._v("opacity")])]),v._v(" "),l("li",[l("code",[v._v("filter")])]),v._v(" "),l("li",[l("code",[v._v("will-change")])]),v._v(" "),l("li",[l("code",[v._v("-webkit-overflow-scrolling")])])])])])]),v._v(" "),l("li",[l("p",[v._v("层叠等级：层叠上下文在 z 轴上的排序:")]),v._v(" "),l("ul",[l("li",[v._v("在同一层叠上下文中，层叠等级才有意义。")]),v._v(" "),l("li",[l("code",[v._v("z-index")]),v._v(" 的优先级最高。\n"),l("img",{attrs:{src:v.$withBase("/assets/css_context.png"),alt:"foo"}})])])])]),v._v(" "),l("h2",{attrs:{id:"bfc-块级格式化上下文"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#bfc-块级格式化上下文"}},[v._v("#")]),v._v(" BFC(块级格式化上下文)")]),v._v(" "),l("p",[v._v("块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。")]),v._v(" "),l("div",{staticClass:"custom-block tip"},[l("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),l("p",[v._v("IE 下为 Layout，可通过 zoom:1 触发")])]),v._v(" "),l("ul",[l("li",[l("p",[v._v("触发条件:")]),v._v(" "),l("ul",[l("li",[v._v("根元素")]),v._v(" "),l("li",[l("code",[v._v("position: absolute/fixed")])]),v._v(" "),l("li",[l("code",[v._v("display: inline-block / table")])]),v._v(" "),l("li",[l("code",[v._v("float 元素")])]),v._v(" "),l("li",[l("code",[v._v("ovevflow !== visible")])])])]),v._v(" "),l("li",[l("p",[v._v("特点：")]),v._v(" "),l("ul",[l("li",[v._v("属于同一个 BFC 的两个相邻 Box 垂直排列。")]),v._v(" "),l("li",[v._v("属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。")]),v._v(" "),l("li",[v._v("BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box 的左边相接触 (子元素 absolute 除外)。")]),v._v(" "),l("li",[v._v("BFC 的区域不会与 float 的元素区域重叠。")]),v._v(" "),l("li",[v._v("计算 BFC 的高度时，浮动子元素也参与计算。")]),v._v(" "),l("li",[v._v("文字层不会被浮动层覆盖，环绕于周围。")])])]),v._v(" "),l("li",[l("p",[v._v("应用：")]),v._v(" "),l("ul",[l("li",[v._v("阻止 "),l("code",[v._v("margin")]),v._v(" 重叠。")]),v._v(" "),l("li",[v._v("可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div 都位于同一个 BFC 区域之中)。")]),v._v(" "),l("li",[v._v("自适应两栏布局。")]),v._v(" "),l("li",[v._v("可以阻止元素被浮动元素覆盖。")])])])]),v._v(" "),l("h2",{attrs:{id:"css-选择器"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#css-选择器"}},[v._v("#")]),v._v(" CSS 选择器")]),v._v(" "),l("ul",[l("li",[v._v("通用选择器(*)")]),v._v(" "),l("li",[v._v("标签选择器（div）")]),v._v(" "),l("li",[v._v("class 选择器(.wrap)")]),v._v(" "),l("li",[v._v("id 选择器（#wrap）")]),v._v(" "),l("li",[v._v("属性选择器(E[att], E[att=val], E[att~=val])\n"),l("ul",[l("li",[v._v("E[att]： 匹配所有具有 att 属性的 E 元素，不考虑它的值。")]),v._v(" "),l("li",[v._v('E[att=val]：匹配所有 att 属性等于"val"的 E 元素。')]),v._v(" "),l("li",[v._v('E[att~=val]：匹配所有 att 属性具有多个空格分隔的值、其中一个值等于"val"的 E 元素。')])])]),v._v(" "),l("li",[v._v("相邻选择器(h1 + p)")]),v._v(" "),l("li",[v._v("子选择器（ul > li）")]),v._v(" "),l("li",[v._v("后代选择器（li a）")]),v._v(" "),l("li",[v._v("伪类选择器\n"),l("ul",[l("li",[v._v("E:first-child：匹配父元素的第一个子元素。")]),v._v(" "),l("li",[v._v("E:link 匹配所有未被点击的链接。")]),v._v(" "),l("li",[v._v("E:focus 匹配获得当前焦点的 E 元素。")]),v._v(" "),l("li",[v._v("E:not(s) 反选伪类，匹配不符合当前选择器的任何元素。")])])])]),v._v(" "),l("div",{staticClass:"custom-block tip"},[l("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),l("ul",[l("li",[v._v("选择器优先级："),l("code",[v._v("!important")]),v._v(" > 行内样式 > "),l("code",[v._v("#id")]),v._v(" > "),l("code",[v._v(".class")]),v._v(" > "),l("code",[v._v("tag")]),v._v(" > "),l("code",[v._v("*")]),v._v(" > 继承 > 默认")]),v._v(" "),l("li",[v._v("选择器 "),l("strong",[v._v("从右往左")]),v._v(" 解析。")])])])])}),[],!1,null,null,null);_.default=i.exports}}]);