<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原理简述 | 全明笔记</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="张全明的个人笔记">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.484694f3.css" as="style"><link rel="preload" href="/assets/js/app.07d4e7d8.js" as="script"><link rel="preload" href="/assets/js/2.e756895e.js" as="script"><link rel="preload" href="/assets/js/23.97f7c972.js" as="script"><link rel="prefetch" href="/assets/js/10.9dcd3981.js"><link rel="prefetch" href="/assets/js/11.7c3a4891.js"><link rel="prefetch" href="/assets/js/12.9123d821.js"><link rel="prefetch" href="/assets/js/13.dc2b3bbc.js"><link rel="prefetch" href="/assets/js/14.8e9572dd.js"><link rel="prefetch" href="/assets/js/15.0831d9fb.js"><link rel="prefetch" href="/assets/js/16.fff0091e.js"><link rel="prefetch" href="/assets/js/17.13d701e1.js"><link rel="prefetch" href="/assets/js/18.c01d73d7.js"><link rel="prefetch" href="/assets/js/19.6d8da221.js"><link rel="prefetch" href="/assets/js/20.7e3bfbe7.js"><link rel="prefetch" href="/assets/js/21.d67b0029.js"><link rel="prefetch" href="/assets/js/22.a1d1221b.js"><link rel="prefetch" href="/assets/js/24.f25bbb61.js"><link rel="prefetch" href="/assets/js/25.886c2813.js"><link rel="prefetch" href="/assets/js/26.d354a60e.js"><link rel="prefetch" href="/assets/js/27.8165f251.js"><link rel="prefetch" href="/assets/js/28.38db902f.js"><link rel="prefetch" href="/assets/js/29.d089321c.js"><link rel="prefetch" href="/assets/js/3.c090ecd3.js"><link rel="prefetch" href="/assets/js/30.7f597fdf.js"><link rel="prefetch" href="/assets/js/31.00125d26.js"><link rel="prefetch" href="/assets/js/32.1b584e55.js"><link rel="prefetch" href="/assets/js/33.b6331f3f.js"><link rel="prefetch" href="/assets/js/34.021e8dad.js"><link rel="prefetch" href="/assets/js/35.2b1e189b.js"><link rel="prefetch" href="/assets/js/36.4643cf1b.js"><link rel="prefetch" href="/assets/js/37.ff936690.js"><link rel="prefetch" href="/assets/js/4.55092137.js"><link rel="prefetch" href="/assets/js/5.02018b5a.js"><link rel="prefetch" href="/assets/js/6.bd7b0c2a.js"><link rel="prefetch" href="/assets/js/7.711e75c5.js"><link rel="prefetch" href="/assets/js/8.35b709e8.js"><link rel="prefetch" href="/assets/js/9.029996af.js">
    <link rel="stylesheet" href="/assets/css/0.styles.484694f3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">全明笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/summary/" class="nav-link router-link-active">
  知识总结
</a></div><div class="nav-item"><a href="/utils/" class="nav-link">
  工具类
</a></div><div class="nav-item"><a href="/links/" class="nav-link">
  学习资料
</a></div><div class="nav-item"><a href="/code/" class="nav-link">
  手写代码
</a></div><div class="nav-item"><a href="https://www.mingme.net/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/zhangquanming/docs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/summary/" class="nav-link router-link-active">
  知识总结
</a></div><div class="nav-item"><a href="/utils/" class="nav-link">
  工具类
</a></div><div class="nav-item"><a href="/links/" class="nav-link">
  学习资料
</a></div><div class="nav-item"><a href="/code/" class="nav-link">
  手写代码
</a></div><div class="nav-item"><a href="https://www.mingme.net/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/zhangquanming/docs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>知识总结</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/" aria-current="page" class="sidebar-link">前言</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/css/base.html" class="sidebar-link">CSS基础知识</a></li><li><a href="/summary/css/layout.html" class="sidebar-link">常见布局方式</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript 相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/javascript/" class="sidebar-link">JavaScript基础知识</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器与网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/http/web.html" class="sidebar-link">浏览器</a></li><li><a href="/summary/http/service.html" class="sidebar-link">服务端与网络</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/framework/vue.html" class="sidebar-link">Vue</a></li><li><a href="/summary/framework/react.html" class="sidebar-link">React</a></li><li><a href="/summary/framework/Hybrid.html" class="sidebar-link">Hybrid</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>构建工具</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/bundler/webpack.html" aria-current="page" class="active sidebar-link">Webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/summary/bundler/webpack.html#原理简述" class="sidebar-link">原理简述</a></li><li class="sidebar-sub-header"><a href="/summary/bundler/webpack.html#loader" class="sidebar-link">Loader</a></li><li class="sidebar-sub-header"><a href="/summary/bundler/webpack.html#plugin" class="sidebar-link">Plugin</a></li><li class="sidebar-sub-header"><a href="/summary/bundler/webpack.html#编译优化" class="sidebar-link">编译优化</a></li><li class="sidebar-sub-header"><a href="/summary/bundler/webpack.html#性能优化思路" class="sidebar-link">性能优化思路</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/monitor/monitor.html" class="sidebar-link">前端监控</a></li><li><a href="/summary/performance/performance.html" class="sidebar-link">项目性能优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>全栈基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/other/node.html" class="sidebar-link">Node</a></li><li><a href="/summary/other/nginx.html" class="sidebar-link">Nginx</a></li><li><a href="/summary/other/docker.html" class="sidebar-link">Docker</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="原理简述"><a href="#原理简述" class="header-anchor">#</a> 原理简述</h2> <p>Webpack 已经成为了现在前端工程化中最重要的一环，通过 <code>Webpack</code> 与 <code>Node</code> 的配合，前端领域完成了不可思议的进步。通过预编译，将软件编程中先进的思想和理念能够真正运用于生产，让前端开发领域告别原始的蛮荒阶段。深入理解 <code>Webpack</code>，可以让你在编程思维及技术领域上产生质的成长，极大拓展技术边界。这也是在面试中必不可少的一个内容。</p> <ul><li><p><strong>核心概念</strong></p> <p>JavaScript 的 <strong>模块打包工具</strong> (module bundler)。通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包 (bundler)，供 HTML 直接引用。实质上，Webpack 仅仅提供了 <strong>打包功能</strong> 和一套 <strong>文件处理机制</strong>，然后通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包。因此 Webpack 具有高度的可拓展性，能更好的发挥社区生态的力量。</p> <ul><li><strong>Entry</strong>: 入口文件，Webpack 会从该文件开始进行分析与编译。</li> <li><strong>Output</strong>: 出口路径，打包后创建 bundler 的文件路径以及文件名。</li> <li><strong>Module</strong>: 模块，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包。</li> <li><strong>Chunk</strong>: 代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能。</li> <li><strong>Loader</strong>: 模块加载器，进行各种文件类型的加载与转换。</li> <li><strong>Plugin</strong>: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改。</li></ul></li> <li><p><strong>工作流程</strong> (初始化 - 编译 - 输出)</p> <ol><li>读取配置文件，按命令 <strong>初始化</strong> 配置参数，创建 Compiler 对象。</li> <li>调用插件的 apply 方法 <strong>挂载插件</strong> 监听，然后从入口文件开始执行编译。</li> <li>按文件类型，调用相应的 Loader 对模块进行 <strong>编译</strong>，并在合适的时机点触发对应的事件，调用 Plugin 执行，最后再根据模块 <strong>依赖查找</strong> 到所依赖的模块，递归执行第三步。</li> <li>将编译后的所有代码包装成一个个代码块 (Chuck)， 并按依赖和配置确定 <strong>输出内容</strong>。这个步骤，仍然可以通过 Plugin 进行文件的修改。</li> <li>最后，根据 Output 把文件内容一一写入到指定的文件夹中，完成整个过程。</li></ol></li> <li><p><strong>模块包装</strong></p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">modules</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 模拟 require 函数，从内存中加载模块；</span>
  <span class="token keyword">function</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span><span class="token parameter">moduleId</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 缓存模块</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>installedModules<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> installedModules<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">.</span>exports
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> module <span class="token operator">=</span> <span class="token punctuation">(</span>installedModules<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">i</span><span class="token operator">:</span> moduleId<span class="token punctuation">,</span>
      <span class="token literal-property property">l</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
      <span class="token literal-property property">exports</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">// 执行代码；</span>
    modules<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>
      module<span class="token punctuation">.</span>exports<span class="token punctuation">,</span>
      module<span class="token punctuation">,</span>
      module<span class="token punctuation">.</span>exports<span class="token punctuation">,</span>
      __webpack_require__
    <span class="token punctuation">)</span>

    <span class="token comment">// Flag: 标记是否加载完成；</span>
    module<span class="token punctuation">.</span>l <span class="token operator">=</span> <span class="token boolean">true</span>

    <span class="token keyword">return</span> module<span class="token punctuation">.</span>exports
  <span class="token punctuation">}</span>

  <span class="token comment">// ...</span>

  <span class="token comment">// 开始执行加载入口文件；</span>
  <span class="token keyword">return</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__webpack_require__<span class="token punctuation">.</span>s <span class="token operator">=</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token string-property property">'./src/index.js'</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>
    <span class="token parameter">module<span class="token punctuation">,</span>
    __webpack_exports__<span class="token punctuation">,</span>
    __webpack_require__</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用 eval 执行编译后的代码；</span>
    <span class="token comment">// 继续递归引用模块内部依赖；</span>
    <span class="token comment">// 实际情况并不是使用模板字符串，这里是为了代码的可读性；</span>
    <span class="token function">eval</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
			__webpack_require__.r(__webpack_exports__);
			//
			var _test__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(&quot;test&quot;, ./src/test.js&quot;);
		</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token string-property property">'./src/test.js'</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">module<span class="token punctuation">,</span> __webpack_exports__<span class="token punctuation">,</span> __webpack_require__</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><p><strong>总结</strong></p> <ul><li><strong>模块机制</strong>: webpack 自己实现了一套模拟模块的机制，将其包裹于业务代码的外部，从而提供了一套模块机制.</li> <li><strong>文件编译</strong>: webpack 规定了一套编译规则，通过 Loader 和 Plugin，以管道的形式对文件字符串进行处理.</li></ul></li></ul> <h2 id="loader"><a href="#loader" class="header-anchor">#</a> Loader</h2> <p>于 Webpack 是基于 Node，因此 Webpack 其实是只能识别 js 模块，比如 css / html / 图片等类型的文件并无法加载，因此就需要一个对 <strong>不同格式文件转换器</strong>。其实 Loader 做的事，也并不难理解: <strong>对 Webpack 传入的字符串进行按需修改</strong>。例如一个最简单的 Loader:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// html-loader/index.js</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">htmlSource</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 返回处理后的代码字符串</span>
  <span class="token comment">// 删除 html 文件中的所有注释</span>
  <span class="token keyword">return</span> htmlSource<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;!--[\w\W]*?--&gt;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然，实际的 Loader 不会这么简单，通常是需要将代码进行分析，构建 <strong>AST (抽象语法树)</strong>， 遍历进行定向的修改后，再重新生成新的代码字符串。如我们常用的 Babel-loader 会执行以下步骤:</p> <ul><li>babylon 将 ES6/ES7 代码解析成 AST</li> <li>babel-traverse 对 AST 进行遍历转译，得到新的 AST</li> <li>新 AST 通过 babel-generator 转换成 ES5</li></ul> <h4 id="loader-特性"><a href="#loader-特性" class="header-anchor">#</a> Loader 特性</h4> <ul><li><strong>链式传递</strong>，按照配置时相反的顺序链式执行。</li> <li>基于 Node 环境，拥有 <strong>较高权限</strong>，比如文件的增删查改。</li> <li>可同步也可异步。</li></ul> <h4 id="常用-loader"><a href="#常用-loader" class="header-anchor">#</a> 常用 Loader</h4> <ul><li>file-loader: 加载文件资源，如 字体 / 图片 等，具有移动/复制/命名等功能。</li> <li>url-loader: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求。</li> <li>babel-loader: 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题。</li> <li>ts-loader: 加载 ts / tsx 文件，编译 TypeScript。</li> <li>style-loader: 将 css 代码以 <code>&lt;style&gt;</code> 标签的形式插入到 html 中。</li> <li>css-loader: 分析 <code>@import</code> 和 <code>url()</code>，引用 css 文件与对应的资源。</li> <li>postcss-loader: 用于 css 的兼容性处理，具有众多功能，例如 <strong>添加前缀</strong>、<strong>单位转换</strong> 等。</li> <li>less-loader / sass-loader: css 预处理器，在 css 中新增了许多语法，提高了开发效率。</li></ul> <h4 id="编写原则"><a href="#编写原则" class="header-anchor">#</a> 编写原则</h4> <ul><li><strong>单一原则</strong>: 每个 Loader 只做一件事。</li> <li><strong>链式调用</strong>: Webpack 会按顺序链式调用每个 Loader。</li> <li><strong>统一原则</strong>: 遵循 Webpack 制定的设计规则和结构，输入与输出均为字符串，各个 Loader 完全独立，即插即用。</li></ul> <h2 id="plugin"><a href="#plugin" class="header-anchor">#</a> Plugin</h2> <p>插件系统是 Webpack 成功的一个关键性因素。在编译的整个生命周期中，Webpack 会触发许多事件钩子，Plugin 可以监听这些事件，根据需求在相应的时间点对打包内容进行定向的修改。</p> <p>一个最简单的 plugin 是这样的:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Plugin</span> <span class="token punctuation">{</span>
  <span class="token comment">// 注册插件时，会调用 apply 方法</span>
  <span class="token comment">// apply 方法接收 compiler 对象</span>
  <span class="token comment">// 通过 compiler 上提供的 Api，可以对事件进行监听，执行相应的操作</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// compilation 是监听每次编译循环</span>
    <span class="token comment">// 每次文件变化，都会生成新的 compilation 对象并触发该事件</span>
    compiler<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token string">'compilation'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">compilation</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="注册插件"><a href="#注册插件" class="header-anchor">#</a> 注册插件</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// webpack.config.js</span>
module<span class="token punctuation">.</span>export <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Plugin</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="事件流机制"><a href="#事件流机制" class="header-anchor">#</a> 事件流机制</h4> <p>Webpack 就像工厂中的一条产品流水线。原材料经过 Loader 与 Plugin 的一道道处理，最后输出结果。</p> <ul><li>通过链式调用，按顺序串起一个个 Loader。</li> <li>通过事件流机制，让 Plugin 可以插入到整个生产过程中的每个步骤中。</li></ul> <p>Webpack 事件流编程范式的核心是基础类 <strong>Tapable</strong>，是一种 <strong>观察者模式</strong> 的实现事件的订阅与广播：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> SyncHook <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'tapable'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'arg'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 订阅</span>
hook<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">arg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 'event-hook'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 广播</span>
<span class="token function">hook</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'event-hook'</span><span class="token punctuation">)</span>
</code></pre></div><p>Webpack 中两个最重要的类 Compiler 与 Compilation 便是继承于 Tapable，也拥有这样的事件流机制。</p> <ul><li><p><strong>Compiler</strong>: 可以简单的理解为 <strong>Webpack 实例</strong>，它包含了当前 Webpack 中的所有配置信息，如 options， loaders, plugins 等信息，全局唯一，只在启动时完成初始化创建，随着生命周期逐一传递。</p></li> <li><p><strong>Compilation</strong>: 可以称为 <strong>编译实例</strong>。当监听到文件发生改变时，Webpack 会创建一个新的 Compilation 对象，开始一次新的编译。它包含了当前的输入资源，输出资源，变化的文件等，同时通过它提供的 api，可以监听每次编译过程中触发的事件钩子。</p></li></ul> <p>区别在于 Compiler 全局唯一，且从启动生存到结束；Compilation 对应每次编译，每轮编译循环均会重新创建。</p> <h4 id="常用-plugin"><a href="#常用-plugin" class="header-anchor">#</a> 常用 Plugin</h4> <ul><li>UglifyJsPlugin: 压缩、混淆代码</li> <li>CommonsChunkPlugin: 代码分割</li> <li>ProvidePlugin: 自动加载模块</li> <li>html-webpack-plugin: 加载 html 文件，并引入 css / js 文件</li> <li>extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件</li> <li>DefinePlugin: 定义全局变量</li> <li>optimize-css-assets-webpack-plugin: CSS 代码去重</li> <li>webpack-bundle-analyzer: 代码分析</li> <li>compression-webpack-plugin: 使用 gzip 压缩 js 和 css</li> <li>happypack: 使用多进程，加速代码构建</li> <li>EnvironmentPlugin: 定义环境变量</li></ul> <h2 id="编译优化"><a href="#编译优化" class="header-anchor">#</a> 编译优化</h2> <ul><li><p><strong>代码优化</strong></p> <ul><li><p><strong>无用代码消除</strong>，是许多编程语言都具有的优化手段，这个过程称为 DCE (dead code elimination)，即 <strong>删除不可能执行的代码</strong></p> <ul><li>例如我们的 UglifyJs，它就会帮我们在生产环境中删除不可能被执行的代码。</li></ul></li> <li><p><strong>摇树优化</strong> (Tree-shaking)，这是一种形象比喻。我们把打包后的代码比喻成一棵树，这里其实表示的就是，通过工具 &quot;摇&quot; 我们打包后的 js 代码，将没有使用到的无用代码 &quot;摇&quot; 下来 (删除)。即 消除那些被 <strong>引用了但未被使用</strong> 的模块代码。</p> <ul><li><strong>原理</strong>: 由于是在编译时优化，因此最基本的前提就是语法的静态分析，<strong>ES6 的模块机制</strong> 提供了这种可能性。不需要运行时，便可进行代码字面上的静态分析，确定相应的依赖关系。</li> <li><strong>问题</strong>: 具有 副作用 的函数无法被 tree-shaking。
<ul><li>在引用一些第三方库，需要去观察其引入的代码量是不是符合预期。</li> <li>尽量写纯函数，减少函数的副作用。</li> <li>可使用 webpack-deep-scope-plugin，可以进行作用域分析，减少此类情况的发生，但仍需要注意。</li></ul></li></ul></li></ul></li> <li><p><strong>code-spliting</strong>: <strong>代码分割</strong> 技术，将代码分割成多份进行 <strong>懒加载</strong> 或 <strong>异步加载</strong>，避免打包成一份后导致体积过大，影响页面的首屏加载。</p> <ul><li>Webpack 中使用 SplitChunksPlugin 进行拆分。</li> <li>按 <strong>页面</strong> 拆分: 不同页面打包成不同的文件。</li> <li>按 <strong>功能</strong> 拆分：
<ul><li>将类似于播放器，计算库等大模块进行拆分后再懒加载引入。</li> <li>提取复用的业务代码，减少冗余代码。</li></ul></li> <li>按 <strong>文件修改频率</strong> 拆分: 将第三方库等不常修改的代码单独打包，而且不改变其文件 hash 值，能最大化运用浏览器的缓存。</li></ul></li> <li><p><strong>scope hoisting: 作用域提升</strong>，将分散的模块划分到同一个作用域中，避免了代码的重复引入，有效减少打包后的代码体积和运行时的内存损耗。</p></li> <li><p><strong>编译性能优化:</strong></p> <ul><li>升级至 <strong>最新</strong> 版本的 webpack，能有效提升编译性能。</li> <li>使用 <strong>dev-server / 模块热替换 (HMR)</strong> 提升开发体验。
<ul><li>监听文件变动 <strong>忽略 node_modules</strong> 目录能有效提高监听时的编译效率。</li></ul></li> <li><strong>缩小编译范围</strong> <ul><li>modules: 指定模块路径，减少递归搜索。</li> <li>mainFields: 指定入口文件描述字段，减少搜索。</li> <li>noParse: 避免对非模块化文件的加载。</li> <li>includes/exclude: 指定搜索范围/排除不必要的搜索范围。</li> <li>alias: 缓存目录，避免重复寻址。</li></ul></li> <li><code>babel-loader</code> <ul><li>忽略 <code>node_moudles</code>，避免编译第三方库中已经被编译过的代码。</li> <li>使用 <code>cacheDirectory</code>，可以缓存编译结果，避免多次重复编译。</li></ul></li> <li><strong>多进程并发</strong> <ul><li>webpack-parallel-uglify-plugin: 可多进程并发压缩 js 文件，提高压缩速度。</li> <li>HappyPack: 多进程并发文件的 Loader 解析。</li></ul></li> <li><strong>第三方库模块缓存</strong> <ul><li>DLLPlugin 和 DLLReferencePlugin 可以提前进行打包并缓存，避免每次都重新编译。</li></ul></li> <li><strong>使用分析</strong> <ul><li>Webpack Analyse / webpack-bundle-analyzer 对打包后的文件进行分析，寻找可优化的地方。</li> <li>配置 <code>profile：true</code> ，对各个编译阶段耗时进行监控，寻找耗时最多的地方。</li></ul></li> <li><code>source-map</code> <ul><li>开发: <code>cheap-module-eval-source-map</code></li> <li>生产: <code>hidden-source-map</code></li></ul></li></ul></li></ul> <h2 id="性能优化思路"><a href="#性能优化思路" class="header-anchor">#</a> 性能优化思路</h2> <p>对于正常的项目优化，一般都涉及到几个方面，<strong>开发过程中</strong>、<strong>上线之后的首屏</strong>、<strong>运行过程的状态</strong></p> <ul><li>开发过程和打包
<ul><li>分析打包速度
<ul><li><code>speed-measure-webpack-plugin</code></li></ul></li> <li>分析影响打包速度环节
<ul><li>获取依赖模块（搜索时间）</li> <li>解析依赖模块（解析时间）</li> <li>依赖模块的打包（压缩时间）</li> <li>运行时的修改（二次打包时间）</li></ul></li> <li>优化解析时间 - 开启多进程打包
<ul><li><code>thread-loader</code></li> <li><code>HappyPack</code></li></ul></li> <li>合理利用缓存（缩短连续构建时间，增加初始构建时间）
<ul><li><code>cache-loader</code></li> <li><code>HardSourceWebpackPlugin</code></li></ul></li> <li>优化压缩时间
<ul><li>webpack3
<ul><li>启动打包时加上 <code>--optimize-minimize</code>(<code>UglifyJsPlugin</code>)</li> <li><code>ParallelUglifyPlugin</code></li></ul></li> <li>webpack4
<ul><li>webpack4 默认内置使用 <code>terser-webpack-plugin</code> 插件压缩优化代码, <code>terser</code> 启动多进程。</li></ul></li></ul></li> <li>优化搜索时间- 缩小文件搜索范围
<ul><li>loader 的 <code>test</code>，<code>include</code>，<code>exclude</code></li> <li>resolve.modules</li> <li>resolve.alias 减少耗时的递归解析操作</li> <li>resolve.extensions （提高命中导入语句文件后缀）</li> <li>resolve.mainFields</li> <li>module.noParse</li></ul></li></ul></li> <li>上线之后的首屏
<ul><li>首屏优化一般涉及到几个指标 FP、FCP、FMP；要有一个良好的体验是尽可能的把 FCP 提前，需要做一些工程化的处理，去优化资源的加载</li> <li>方式及分包策略，资源的减少是最有效的加快首屏打开的方式</li> <li>骨架屏及预渲染（部分结构预渲染）、suspence 与 lazy 做懒加载动态组件的方式</li> <li>SSR 对于 SEO 和首屏的优化有一定的优势</li></ul></li> <li>运行状态
<ul><li>react 项目上线之后，首先需要保障的是可用性，所以可以通过 React.Profiler 分析组件的渲染次数及耗时的一些任务，但是 Profile 记录的是 commit 阶段的数据，所以对于 react 的调和阶段就需要结合 performance API 一起分析</li> <li>由于 React 是父级 props 改变之后，所有与 props 不相关子组件在没有添加条件控制的情况之下，也会触发 render 渲染，这是没有必要的，可以结合 React 的 PureComponent 以及 React.memo 等做浅比较处理，这中间有涉及到不可变数据的处理，当然也可以结合使用 ShouldComponentUpdate 做深比较处理</li> <li>所有的运行状态优化，都是减少不必要的 render，React.useMemo 与 React.useCallback 也是可以做很多优化的地方</li> <li>在很多应用中，都会涉及到使用 redux 以及使用 context，这两个都可能造成许多不必要的 render，所以在使用的时候，也需要谨慎的处理一些数据</li> <li>最后就是保证整个应用的可用性，为组件创建错误边界，可以使用 componentDidCatch 来处理</li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">11/18/2022, 5:42:50 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/summary/framework/Hybrid.html" class="prev">
        Hybrid
      </a></span> <span class="next"><a href="/summary/monitor/monitor.html">
        前端监控
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.07d4e7d8.js" defer></script><script src="/assets/js/2.e756895e.js" defer></script><script src="/assets/js/23.97f7c972.js" defer></script>
  </body>
</html>
