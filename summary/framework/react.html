<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Fiber | 全明笔记</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="张全明的个人笔记">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.484694f3.css" as="style"><link rel="preload" href="/assets/js/app.07d4e7d8.js" as="script"><link rel="preload" href="/assets/js/2.e756895e.js" as="script"><link rel="preload" href="/assets/js/27.8165f251.js" as="script"><link rel="prefetch" href="/assets/js/10.9dcd3981.js"><link rel="prefetch" href="/assets/js/11.7c3a4891.js"><link rel="prefetch" href="/assets/js/12.9123d821.js"><link rel="prefetch" href="/assets/js/13.dc2b3bbc.js"><link rel="prefetch" href="/assets/js/14.8e9572dd.js"><link rel="prefetch" href="/assets/js/15.0831d9fb.js"><link rel="prefetch" href="/assets/js/16.fff0091e.js"><link rel="prefetch" href="/assets/js/17.13d701e1.js"><link rel="prefetch" href="/assets/js/18.c01d73d7.js"><link rel="prefetch" href="/assets/js/19.6d8da221.js"><link rel="prefetch" href="/assets/js/20.7e3bfbe7.js"><link rel="prefetch" href="/assets/js/21.d67b0029.js"><link rel="prefetch" href="/assets/js/22.a1d1221b.js"><link rel="prefetch" href="/assets/js/23.97f7c972.js"><link rel="prefetch" href="/assets/js/24.f25bbb61.js"><link rel="prefetch" href="/assets/js/25.886c2813.js"><link rel="prefetch" href="/assets/js/26.d354a60e.js"><link rel="prefetch" href="/assets/js/28.38db902f.js"><link rel="prefetch" href="/assets/js/29.d089321c.js"><link rel="prefetch" href="/assets/js/3.c090ecd3.js"><link rel="prefetch" href="/assets/js/30.7f597fdf.js"><link rel="prefetch" href="/assets/js/31.00125d26.js"><link rel="prefetch" href="/assets/js/32.1b584e55.js"><link rel="prefetch" href="/assets/js/33.b6331f3f.js"><link rel="prefetch" href="/assets/js/34.021e8dad.js"><link rel="prefetch" href="/assets/js/35.2b1e189b.js"><link rel="prefetch" href="/assets/js/36.4643cf1b.js"><link rel="prefetch" href="/assets/js/37.ff936690.js"><link rel="prefetch" href="/assets/js/4.55092137.js"><link rel="prefetch" href="/assets/js/5.02018b5a.js"><link rel="prefetch" href="/assets/js/6.bd7b0c2a.js"><link rel="prefetch" href="/assets/js/7.711e75c5.js"><link rel="prefetch" href="/assets/js/8.35b709e8.js"><link rel="prefetch" href="/assets/js/9.029996af.js">
    <link rel="stylesheet" href="/assets/css/0.styles.484694f3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">全明笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/summary/" class="nav-link router-link-active">
  知识总结
</a></div><div class="nav-item"><a href="/utils/" class="nav-link">
  工具类
</a></div><div class="nav-item"><a href="/links/" class="nav-link">
  学习资料
</a></div><div class="nav-item"><a href="/code/" class="nav-link">
  手写代码
</a></div><div class="nav-item"><a href="https://www.mingme.net/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/zhangquanming/docs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/summary/" class="nav-link router-link-active">
  知识总结
</a></div><div class="nav-item"><a href="/utils/" class="nav-link">
  工具类
</a></div><div class="nav-item"><a href="/links/" class="nav-link">
  学习资料
</a></div><div class="nav-item"><a href="/code/" class="nav-link">
  手写代码
</a></div><div class="nav-item"><a href="https://www.mingme.net/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/zhangquanming/docs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>知识总结</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/" aria-current="page" class="sidebar-link">前言</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/css/base.html" class="sidebar-link">CSS基础知识</a></li><li><a href="/summary/css/layout.html" class="sidebar-link">常见布局方式</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript 相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/javascript/" class="sidebar-link">JavaScript基础知识</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器与网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/http/web.html" class="sidebar-link">浏览器</a></li><li><a href="/summary/http/service.html" class="sidebar-link">服务端与网络</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>前端框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/framework/vue.html" class="sidebar-link">Vue</a></li><li><a href="/summary/framework/react.html" aria-current="page" class="active sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/summary/framework/react.html#fiber" class="sidebar-link">Fiber</a></li><li class="sidebar-sub-header"><a href="/summary/framework/react.html#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/summary/framework/react.html#组件通信" class="sidebar-link">组件通信</a></li><li class="sidebar-sub-header"><a href="/summary/framework/react.html#setstate" class="sidebar-link">setState</a></li><li class="sidebar-sub-header"><a href="/summary/framework/react.html#hoc-高阶组件" class="sidebar-link">HOC(高阶组件)</a></li><li class="sidebar-sub-header"><a href="/summary/framework/react.html#redux" class="sidebar-link">Redux</a></li><li class="sidebar-sub-header"><a href="/summary/framework/react.html#react-hooks" class="sidebar-link">React Hooks</a></li><li class="sidebar-sub-header"><a href="/summary/framework/react.html#ssr" class="sidebar-link">SSR</a></li><li class="sidebar-sub-header"><a href="/summary/framework/react.html#函数式编程" class="sidebar-link">函数式编程</a></li></ul></li><li><a href="/summary/framework/Hybrid.html" class="sidebar-link">Hybrid</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>构建工具</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/bundler/webpack.html" class="sidebar-link">Webpack</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/monitor/monitor.html" class="sidebar-link">前端监控</a></li><li><a href="/summary/performance/performance.html" class="sidebar-link">项目性能优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>全栈基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/other/node.html" class="sidebar-link">Node</a></li><li><a href="/summary/other/nginx.html" class="sidebar-link">Nginx</a></li><li><a href="/summary/other/docker.html" class="sidebar-link">Docker</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="fiber"><a href="#fiber" class="header-anchor">#</a> Fiber</h2> <p>React 的核心流程可以分为两个部分:</p> <ul><li>reconciliation (<strong>调度算法</strong>，也可称为 render):
<ul><li>更新 state 与 props；</li> <li>调用生命周期钩子；</li> <li>生成 virtual dom；
<ul><li>这里应该称为 Fiber Tree 更为符合；</li></ul></li> <li>通过新旧 vdom 进行 diff 算法，获取 vdom change；</li> <li>确定是否需要重新渲染</li></ul></li> <li>commit:
<ul><li>如需要，则操作 dom 节点更新；</li></ul></li></ul> <p>要了解 Fiber，我们首先来看为什么需要它？</p> <ul><li><p><strong>问题</strong>: 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 <strong>同步阻塞</strong>。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 <strong>同步递归</strong> 的方式进行遍历渲染，而这个过程最大的问题就是无法 <strong>暂停和恢复</strong>。</p></li> <li><p><strong>解决方案</strong>: 解决同步阻塞的方法，通常有两种: <strong>异步</strong> 与 <strong>任务分割</strong>。而 React Fiber 便是为了实现任务分割而诞生的。</p></li> <li><p><strong>简述</strong>:</p> <ul><li>在 React V16 将调度算法进行了重构， 将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的 <strong>单链表树遍历算法</strong>。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启。</li> <li>这里我理解为是一种 <strong>任务分割调度算法</strong>，主要是 将原先同步更新渲染的任务分割成一个个独立的 <strong>小任务单位</strong>，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制。</li></ul></li> <li><p><strong>核心</strong>:</p> <ul><li>Fiber 这里可以具象为一个 <strong>数据结构</strong>:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Fiber</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">instance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> instance
    <span class="token comment">// 指向第一个 child 节点</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> child
    <span class="token comment">// 指向父节点</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> parent
    <span class="token comment">// 指向第一个兄弟节点</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> previous
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p><strong>链表树遍历算法</strong>: 通过 <strong>节点保存与映射</strong>，便能够随时地进行 <strong>停止和重启</strong>，这样便能达到实现任务分割的基本前提；</p> <ul><li>1、首先通过不断遍历子节点，到树末尾；</li> <li>2、开始通过 sibling 遍历兄弟节点；</li> <li>3、return 返回父节点，继续执行 2；</li> <li>4、直到 root 节点后，跳出遍历；</li></ul></li> <li><p><strong>任务分割</strong>，React 中的渲染更新可以分成两个阶段:</p> <ul><li><strong>reconciliation 阶段</strong>: vdom 的数据对比，是个适合拆分的阶段，比如对比一部分树后，先暂停执行个动画调用，待完成后再回来继续比对。</li> <li><strong>Commit 阶段</strong>: 将 change list 更新到 dom 上，并不适合拆分，才能保持数据与 UI 的同步。否则可能由于阻塞 UI 更新，而导致数据更新和 UI 不一致的情况。</li></ul></li> <li><p><strong>分散执行</strong>: 任务分割后，就可以把小任务单元分散到浏览器的空闲期间去排队执行，而实现的关键是两个新 API: <code>requestIdleCallback</code> 与 <code>requestAnimationFrame</code></p> <ul><li>低优先级的任务交给 <code>requestIdleCallback</code> 处理，这是个浏览器提供的事件循环空闲期的回调函数，需要 pollyfill，而且拥有 deadline 参数，限制执行事件，以继续切分任务；</li> <li>高优先级的任务交给 <code>requestAnimationFrame</code> 处理；</li></ul></li> <li><p><strong>优先级策略</strong>: 文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务</p></li></ul></li></ul> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>Fiber 其实可以算是一种编程思想，在其它语言中也有许多应用(Ruby Fiber)。核心思想是 任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。</p> <p>当遇到进程阻塞的问题时，任务分割、异步调用 和 缓存策略 是三个显著的解决思路。</p></div> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <p>在新版本中，React 官方对生命周期有了新的 <strong>变动建议</strong>:</p> <ul><li>使用 <code>getDerivedStateFromProps</code> 替换 <code>componentWillMount</code> 与 <code>componentWillReceiveProps</code>；</li> <li>使用 <code>getSnapshotBeforeUpdate</code> 替换 <code>componentWillUpdate</code>；</li> <li>避免使用 <code>componentWillReceiveProps</code>;</li></ul> <p>其实该变动的原因，正是由于上述提到的 Fiber。首先，从上面我们知道 React 可以分成 reconciliation 与 commit 两个阶段，对应的生命周期如下:</p> <ul><li><p><strong>reconciliation</strong>:</p> <ul><li><code>componentWillMount</code></li> <li><code>componentWillReceiveProps</code></li> <li><code>shouldComponentUpdate</code></li> <li><code>componentWillUpdate</code></li></ul></li> <li><p><strong>commit</strong>:</p> <ul><li><code>componentDidMount</code></li> <li><code>componentDidUpdate</code></li> <li><code>componentWillUnmount</code></li></ul></li></ul> <p>在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 <strong>暂停</strong> 和 <strong>重启</strong>，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被 <strong>多次调用</strong> 的情况，产生一些意外错误。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// 替换 `componentWillReceiveProps` ，</span>
  <span class="token comment">// 初始化和 update 时被调用</span>
  <span class="token comment">// 静态函数，无法使用 this</span>
  <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 判断是否需要更新组件</span>
  <span class="token comment">// 可以用于组件性能优化</span>
  <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> nextState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 组件被挂载后触发</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 替换 componentWillUpdate</span>
  <span class="token comment">// 可以在更新之前获取最新 dom 数据</span>
  <span class="token function">getSnapshotBeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 组件更新后调用</span>
  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 组件即将销毁</span>
  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 组件已销毁</span>
  <span class="token function">componentDidUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p><strong>使用建议</strong>:</p> <ul><li><p>在 <code>constructor</code> 初始化 state；</p></li> <li><p>在 <code>componentDidMount</code> 中进行事件监听，并在 <code>componentWillUnmount</code> 中解绑事件；</p></li> <li><p>在 <code>componentDidMount</code> 中进行数据的请求，而不是在 <code>componentWillMount</code>；</p></li> <li><p>需要根据 props 更新 state 时，使用 <code>getDerivedStateFromProps(nextProps, prevState)</code>；</p> <ul><li>旧 props 需要自己存储，以便比较；</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps<span class="token punctuation">,</span> prevState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当新 props 中的 data 发生变化时，同步更新到 state 上</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextProps<span class="token punctuation">.</span>data <span class="token operator">!==</span> prevState<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">data</span><span class="token operator">:</span> nextProps<span class="token punctuation">.</span>data
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> null1
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>可以在 <code>componentDidUpdate</code> 监听 props 或者 state 的变化，例如:</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当 id 发生变化时，重新获取数据</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id <span class="token operator">!==</span> prevProps<span class="token punctuation">.</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>在 <code>componentDidUpdate</code> 使用 <code>setState</code> 时，必须加条件，否则将进入死循环；</li> <li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code> 可以在更新之前获取最新的渲染数据，它的调用是在 render 之后， update 之前；</li> <li><code>shouldComponentUpdate</code>: 默认每次调用 <code>setState</code>，一定会最终走到 diff 阶段，但可以通过 <code>shouldComponentUpdate</code> 的生命钩子返回 <code>false</code> 来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能。</li></ul></li></ul> <h2 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h2> <ul><li>父组件向子组件通信：父组件通过 props 向子组件传递需要的信息。</li> <li>子组件向父组件通信：props+回调的方式。</li> <li>跨级组件通信: props 层层传递、context</li> <li>非嵌套关系的组件通信： 自定义事件通信（发布订阅模式）、redux 等状态管理</li></ul> <h2 id="setstate"><a href="#setstate" class="header-anchor">#</a> setState</h2> <p>在了解 <code>setState</code> 之前，先来简单了解下 React 一个包装结构: <strong>Transaction</strong>:</p> <ul><li><p><strong>事务</strong> (Transaction)：</p> <ul><li>是 <code>React</code> 中的一个调用结构，用于包装一个方法，结构为: <strong>initialize - perform(method) - close</strong>。通过事务，可以统一管理一个方法的开始与结束；处于事务流中，表示进程正在执行一些操作</li></ul></li> <li><p><code>setState</code>: React 中用于修改状态，更新视图。它具有以下特点:</p></li> <li><p>异步与同步: <code>setState</code> 并不是单纯的异步或同步，这其实与调用时的环境相关:</p> <ul><li><p>在 <strong>合成事件</strong> 和 <strong>生命周期钩子(除 componentDidUpdate)</strong> 中 <code>setState</code> 是&quot;异步&quot;的；</p> <ul><li><p><strong>原因</strong>: 因为在 <code>setState</code> 的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入 <code>dirtyComponents</code> 队列中等待执行；否则，开始执行 <code>batchedUpdates</code> 队列更新；</p> <ul><li>在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而 <code>componentDidUpdate</code> 是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；</li> <li>在合成事件中，<code>React</code> 是基于 <strong>事务流完成的事件委托机制</strong> 实现，也是处于事务流中；</li></ul></li> <li><p><strong>问题</strong>: 无法在 <code>setState</code> 后马上从 <code>this.state</code> 上获取更新后的值。</p></li> <li><p><strong>解决</strong>: 如果需要马上同步去获取新值，<code>setState</code> 其实是可以传入第二个参数的。<code>setState(updater, callback)</code>，在回调中即可获取最新值；</p></li></ul></li> <li><p>在 <strong>原生事件</strong> 和 <strong>setTimeout</strong> 中，<code>setState</code> 是同步的，可以马上获取更新后的值；</p> <ul><li><strong>原因</strong>: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而 <code>setTimeout</code> 是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；</li></ul></li></ul></li> <li><p><strong>批量更新</strong>: 在 <strong>合成事件</strong> 和 <strong>生命周期钩子</strong> 中，<code>setState</code> 更新队列时，存储的是 <strong>合并状态(Object.assign)</strong>。因此前面设置的 <code>key</code> 值会被后面所覆盖，最终只会执行一次更新；</p></li> <li><p><strong>函数式</strong>: 由于 <strong>Fiber</strong> 及 <strong>合并</strong> 的问题，官方推荐可以传入 <strong>函数</strong> 的形式。<code>setState(fn)</code>，在 <code>fn</code> 中返回新的 <code>state</code> 对象即可，例如 <code>this.setState((state, props) =&gt; newState)</code>；</p> <ul><li>使用函数式，可以用于避免 <code>setState</code> 的批量更新的逻辑，传入的函数将会被 <strong>顺序调用</strong>；</li></ul></li> <li><p><strong>注意事项:</strong></p> <ul><li><code>setState</code> 合并，在 合成事件 和 生命周期钩子 中多次连续调用会被优化为一次；</li> <li>当组件已被销毁，如果再次调用 <code>setState</code>，React 会报错警告，通常有两种解决办法:
<ul><li>将数据挂载到外部，通过 <code>props</code> 传入，如放到 Redux 或 父级中；</li> <li>在组件内部维护一个状态量 (isUnmounted)，<code>componentWillUnmount</code> 中标记为 <code>true</code>，在 <code>setState</code> 前进行判断；</li></ul></li></ul></li></ul> <h2 id="hoc-高阶组件"><a href="#hoc-高阶组件" class="header-anchor">#</a> HOC(高阶组件)</h2> <p>HOC(Higher Order Componennt) 是在 React 机制下社区形成的一种组件模式，在很多第三方开源库中表现强大。</p> <ul><li><p><strong>简述:</strong></p> <ul><li>高阶组件不是组件，是 <strong>增强函数</strong>，可以输入一个元组件，返回出一个新的增强组件；</li> <li>高阶组件的主要作用是 <strong>代码复用</strong>，<strong>操作</strong> 状态和参数；</li></ul></li> <li><p><strong>用法:</strong></p> <ul><li><p><strong>属性代理 (Props Proxy)</strong>: 返回出一个组件，它基于被包裹组件进行 <strong>功能增强</strong>；</p> <ul><li><p><strong>默认参数</strong>: 可以为组件包裹一层默认参数；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">proxyHoc</span><span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> newProps <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'tayde'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>Comp <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>newProps<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><strong>提取状态</strong>: 可以通过 props 将被包裹组件中的 state 依赖外层，例如用于转换受控组件:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">withOnChange</span><span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function-variable function">onChangeName</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'dongdong'</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> newProps <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
        <span class="token literal-property property">onChange</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onChangeName<span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>Comp <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>newProps<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用姿势如下，这样就能非常快速的将一个 Input 组件转化成受控组件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">NameInput</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>input name<span class="token operator">=</span><span class="token string">&quot;name&quot;</span> <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withOnChange</span><span class="token punctuation">(</span>NameInput<span class="token punctuation">)</span>
</code></pre></div></li> <li><p><strong>包裹组件</strong>: 可以为被包裹元素进行一层包装，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">withMask</span><span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
      <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span>
          <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>Comp <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
          <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
            <span class="token literal-property property">width</span><span class="token operator">:</span> <span class="token string">'100%'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">height</span><span class="token operator">:</span> <span class="token string">'100%'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">backgroundColor</span><span class="token operator">:</span> <span class="token string">'rgba(0, 0, 0, .6)'</span><span class="token punctuation">,</span>
          <span class="token punctuation">}</span><span class="token punctuation">}</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p><strong>反向继承</strong> (Inheritance Inversion): 返回出一个组件，<strong>继承于被包裹组件</strong>，常用于以下操作:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">IIHoc</span><span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> Comp <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p><strong>渲染劫持</strong> (Render Highjacking)</p> <ul><li><p><strong>条件渲染</strong>: 根据条件，渲染不同的组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">withLoading</span><span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> Comp <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>isLoading<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span>Loading <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>可以直接修改被包裹组件渲染出的 React 元素树</p></li></ul></li> <li><p><strong>操作状态</strong> (Operate State): 可以直接通过 <code>this.state</code> 获取到被包裹组件的状态，并进行操作。但这样的操作容易使 state 变得难以追踪，不易维护，谨慎使用。</p></li></ul></li></ul></li> <li><p><strong>应用场景:</strong></p> <ul><li><p><strong>权限控制</strong>，通过抽象逻辑，统一对页面进行权限判断，按不同的条件进行页面渲染:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">withAdminAuth</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">isAdmin</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">async</span> <span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> currentRole <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getCurrentUserRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token literal-property property">isAdmin</span><span class="token operator">:</span> currentRole <span class="token operator">===</span> <span class="token string">'Admin'</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>isAdmin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span>Comp <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>您没有权限查看该页面，请联系管理员！<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><strong>性能监控</strong>，包裹组件的生命周期，进行统一埋点:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">withTiming</span><span class="token punctuation">(</span><span class="token parameter">Comp</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> Comp <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">super</span><span class="token punctuation">.</span>componentDidMount <span class="token operator">&amp;&amp;</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
        <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>WrappedComponent<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 组件渲染时间为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>start
        <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> ms</span><span class="token template-punctuation string">`</span></span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><strong>代码复用</strong>，可以将重复的逻辑进行抽象。</p></li></ul></li> <li><p><strong>使用注意:</strong></p> <ul><li>纯函数: 增强函数应为纯函数，避免侵入修改元组件；</li> <li>避免用法污染: 理想状态下，应透传元组件的无关参数与事件，尽量保证用法不变；</li> <li>命名空间: 为 HOC 增加特异性的组件名称，这样能便于开发调试和查找问题；</li> <li>引用传递: 如果需要传递元组件的 <code>refs</code> 引用，可以使用 <code>React.forwardRef</code>；</li> <li>静态方法: 元组件上的静态方法并无法被自动传出，会导致业务层无法调用；解决:
<ul><li>函数导出</li> <li>静态方法赋值</li></ul></li> <li>重新渲染: 由于增强函数每次调用是返回一个新组件，因此如果在 Render 中使用增强函数，就会导致每次都重新渲染整个 HOC，而且之前的状态会丢失；</li></ul></li></ul> <h2 id="redux"><a href="#redux" class="header-anchor">#</a> Redux</h2> <p>Redux 是一个 <strong>数据管理中心</strong>，可以把它理解为一个全局的 data store 实例。它通过一定的使用规则和限制，保证着数据的健壮性、可追溯和可预测性。它与 React 无关，可以独立运行于任何 JavaScript 环境中，从而也为同构应用提供了更好的数据同步通道。</p> <ul><li><p><strong>核心理念:</strong></p> <ul><li><p><strong>单一数据源</strong>: 整个应用只有唯一的状态树，也就是所有 state 最终维护在一个根级 Store 中；</p></li> <li><p><strong>状态只读</strong>: 为了保证状态的可控性，最好的方式就是监控状态的变化。那这里就两个必要条件：</p> <ul><li>Redux Store 中的数据无法被直接修改</li> <li>严格控制修改的执行；</li></ul></li> <li><p><strong>纯函数</strong>: 规定只能通过一个纯函数 (Reducer) 来描述修改；</p></li></ul></li> <li><p><strong>理念实现:</strong></p> <ul><li><p><strong>Store</strong>: 全局 Store 单例， 每个 Redux 应用下只有一个 store， 它具有以下方法供使用:</p> <ul><li><code>getState</code>: 获取 state；</li> <li><code>dispatch</code>: 触发 action, 更新 state；</li> <li><code>subscribe</code>: 订阅数据变更，注册监听器；</li></ul></li> <li><p><strong>Action</strong>: 它作为一个行为载体，用于映射相应的 Reducer，并且它可以成为数据的载体，将数据从应用传递至 store 中，是 store <strong>唯一的数据源</strong>；</p></li> <li><p><strong>Reducer</strong>: 用于描述如何修改数据的纯函数，Action 属于行为名称，而 Reducer 便是修改行为的实质；</p></li></ul></li> <li><p><strong>React-Redux</strong></p> <ul><li><p><strong>React-Redux</strong>: 结合 React 使用；</p> <ul><li><p><code>&lt;Provider&gt;</code>: 将 store 通过 context 传入组件中；</p></li> <li><p><code>connect</code>: 一个高阶组件，可以方便在 React 组件中使用 Redux；</p> <ol><li>将 <code>store</code> 通过 <code>mapStateToProps</code> 进行筛选后使用 <code>props</code> 注入组件</li> <li>根据 <code>mapDispatchToProps</code> 创建方法，当组件调用时使用 <code>dispatch</code> 触发对应的 <code>action</code></li></ol></li></ul></li> <li><p><strong>Reducer 的拆分与重构</strong></p> <ul><li><p>随着项目越大，如果将所有状态的 reducer 全部写在一个函数中，将会 <strong>难以维护</strong>；</p></li> <li><p>可以将 reducer 进行拆分，也就是 <strong>函数分解</strong>，最终再使用 <code>combineReducers()</code> 进行重构合并；</p></li></ul></li> <li><p><strong>异步 Action</strong>: 由于 Reducer 是一个严格的纯函数，因此无法在 Reducer 中进行数据的请求，需要先获取数据，再 <code>dispatch(Action)</code> 即可，下面是三种不同的异步实现:</p> <ul><li><a href="https://github.com/reduxjs/redux-thunk" target="_blank" rel="noopener noreferrer">redex-thunk<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noopener noreferrer">redux-saga<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/redux-observable/redux-observable" target="_blank" rel="noopener noreferrer">redux-observable<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></li></ul></li></ul> <h2 id="react-hooks"><a href="#react-hooks" class="header-anchor">#</a> React Hooks</h2> <p>React 中通常使用 <strong>类定义</strong> 或者 <strong>函数定义</strong> 创建组件:</p> <p>在类定义中，我们可以使用到许多 React 特性，例如 state、 各种组件生命周期钩子等，但是在函数定义中，我们却无能为力，因此 React 16.8 版本推出了一个新功能 (React Hooks)，通过它，可以更好的在函数定义组件中使用 React 特性。</p> <ul><li><p><strong>好处</strong></p> <ul><li><p><strong>跨组件复用</strong>: 其实 render props / HOC 也是为了复用，相比于它们，Hooks 作为官方的底层 API，最为轻量，而且改造成本小，不会影响原来的组件层次结构和传说中的嵌套地狱；</p></li> <li><p><strong>类定义更为复杂</strong></p> <ul><li>不同的生命周期会使逻辑变得分散且混乱，不易维护和管理；</li> <li>时刻需要关注 <code>this</code> 的指向问题；</li> <li>代码复用代价高，高阶组件的使用经常会使整个组件树变得臃肿；</li></ul></li> <li><p><strong>状态与 UI 隔离</strong>: 正是由于 Hooks 的特性，状态逻辑会变成更小的粒度，并且极容易被抽象成一个自定义 Hooks，组件中的状态和 UI 变得更为清晰和隔离。</p></li></ul></li> <li><p><strong>注意</strong></p> <ul><li>避免在 循环/条件判断/嵌套函数 中调用 hooks，保证调用顺序的稳定；</li> <li>只有 函数定义组件 和 hooks 可以调用 hooks，避免在 类组件 或者 普通函数 中调用；</li> <li>不能在 <code>useEffect</code> 中使用 <code>useState</code>，React 会报错提示；</li> <li>类组件不会被替换或废弃，不需要强制改造类组件，两种方式能并存；</li></ul></li> <li><p><strong>重要钩子</strong></p> <ul><li><p><strong>状态钩子</strong> (<code>useState</code>): 用于定义组件的 State，其到类定义中 <code>this.state</code> 的功能；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// useState 只接受一个参数: 初始状态</span>
<span class="token comment">// 返回的是组件名和更改该组件对应的函数</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>flag<span class="token punctuation">,</span> setFlag<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token comment">// 修改状态</span>
<span class="token function">setFlag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>

<span class="token comment">// 上面的代码映射到类定义中:</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">flag</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> flag <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>flag
<span class="token keyword">const</span> <span class="token function-variable function">setFlag</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">bool</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">flag</span><span class="token operator">:</span> bool<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p><strong>生命周期钩子</strong> (<code>useEffect</code>):</p> <p>类定义中有许多生命周期函数，而在 React Hooks 中也提供了一个相应的函数 (<code>useEffect</code>)，这里可以看做 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 的结合。</p> <ul><li><p><code>useEffect(callback, [source])</code> 接受两个参数</p> <ul><li><code>callback</code>: 钩子回调函数；</li> <li><code>source</code>: 设置触发条件，仅当 source 发生改变时才会触发；</li> <li><code>useEffect</code> 钩子在没有传入 <code>[source]</code> 参数时，默认在每次 render 时都会优先调用上次保存的回调中返回的函数，后再重新调用回调；</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 组件挂载后执行事件绑定</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'on'</span><span class="token punctuation">)</span>
  <span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token comment">// 组件 update 时会执行事件解绑</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'off'</span><span class="token punctuation">)</span>
    <span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>source<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 每次 source 发生改变时，执行结果(以类定义的生命周期，便于大家理解):</span>
<span class="token comment">// --- DidMount ---</span>
<span class="token comment">// 'on'</span>
<span class="token comment">// --- DidUpdate ---</span>
<span class="token comment">// 'off'</span>
<span class="token comment">// 'on'</span>
<span class="token comment">// --- DidUpdate ---</span>
<span class="token comment">// 'off'</span>
<span class="token comment">// 'on'</span>
<span class="token comment">// --- WillUnmount ---</span>
<span class="token comment">// 'off'</span>
</code></pre></div></li></ul></li> <li><p><strong>其他内置钩子</strong></p> <ul><li><p><code>useContext</code>: 获取 context 对象</p></li> <li><p><code>useReducer</code>: 类似于 Redux 思想的实现，但其并不足以替代 Redux，可以理解成一个组件内部的 redux:</p> <ul><li>并不是持久化存储，会随着组件被销毁而销毁；</li> <li>属于组件内部，各个组件是相互隔离的，单纯用它并无法共享数据；</li> <li>配合 <code>useContext</code> 的全局性，可以完成一个轻量级的 Redux；(<a href="https://github.com/ctrlplusb/easy-peasy" target="_blank" rel="noopener noreferrer">easy-peasy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</li></ul></li> <li><p><code>useCallback</code>: 缓存回调函数，避免传入的回调每次都是新的函数实例而导致依赖组件重新渲染，具有性能优化的效果；</p></li> <li><p><code>useMemo</code>: 用于缓存传入的 props，避免依赖的组件每次都重新渲染；</p></li> <li><p><code>useRef</code>: 获取组件的真实节点；</p></li> <li><p><code>useLayoutEffect</code>:</p> <ul><li>DOM 更新同步钩子。用法与 <code>useEffect</code> 类似，只是区别于执行时间点的不同。</li> <li><code>useEffect</code> 属于异步执行，并不会等待 DOM 真正渲染后执行，而 <code>useLayoutEffect</code> 则会真正渲染后才触发；</li> <li>可以获取更新后的 state；</li></ul></li></ul></li> <li><p><strong>自定义钩子</strong>(<code>useXxxxx</code>): 基于 Hooks 可以引用其它 Hooks 这个特性，我们可以编写自定义钩子。例如，我们需要每个页面自定义标题:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useTitle</span><span class="token punctuation">(</span><span class="token parameter">title</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>title <span class="token operator">=</span> title
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用:</span>
<span class="token keyword">function</span> <span class="token function">Home</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> title <span class="token operator">=</span> <span class="token string">'我是首页'</span>
  <span class="token function">useTitle</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="ssr"><a href="#ssr" class="header-anchor">#</a> SSR</h2> <p>SSR，俗称 <strong>服务端渲染</strong> (Server Side Render)，讲人话就是: 直接在服务端层获取数据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。</p> <ul><li><strong>前后端分离</strong>: 前端与服务端隔离，前端动态获取数据，渲染页面。</li></ul> <ul><li><p><strong>痛点</strong>：</p> <ul><li><p><strong>首屏渲染性能瓶颈:</strong></p> <ul><li>空白延迟: HTML 下载时间 + JS 下载/执行时间 + 请求时间 + 渲染时间。在这段时间内，页面处于空白的状态。</li></ul></li> <li><p><strong>SEO 问题</strong>: 由于页面初始状态为空，因此爬虫无法获取页面中任何有效数据，因此对搜索引擎不友好。</p></li></ul></li></ul> <h2 id="函数式编程"><a href="#函数式编程" class="header-anchor">#</a> 函数式编程</h2> <p>函数式编程是一种 <strong>编程范式</strong>，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础与边界法则，追求的是 <strong>更简洁、可预测、高复用、易测试</strong>。其实在现有的众多知名库中，都蕴含着丰富的函数式编程思想，如 React / Redux 等。</p> <ul><li><p><strong>常见的编程范式:</strong></p> <ul><li>命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做什么；</li> <li>事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；</li> <li>面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承性、多态性；</li> <li>函数式编程</li></ul></li> <li><p><strong>函数式编程的理念:</strong></p> <ul><li><p><strong>纯函数</strong>(确定性函数): 是函数式编程的基础，可以使程序变得灵活，高度可拓展，可维护；</p> <ul><li><p><strong>优势:</strong></p> <ul><li>完全独立，与外部解耦；</li> <li>高度可复用，在任意上下文，任意时间线上，都可执行并且保证结果稳定；</li> <li>可测试性极强；</li></ul></li> <li><p><strong>条件:</strong></p> <ul><li>不修改参数；</li> <li>不依赖、不修改任何函数外部的数据；</li> <li>完全可控，参数一样，返回值一定一样: 例如函数不能包含 <code>new Date()</code> 或者 <code>Math.rando()</code> 等这种不可控因素；</li> <li>引用透明；</li></ul></li> <li><p>我们常用到的许多 API 或者工具函数，它们都具有着纯函数的特点， 如 <code>split / join / map</code>；</p></li></ul></li> <li><p><strong>函数复合</strong>: 将多个函数进行组合后调用，可以实现将一个个函数单元进行组合，达成最后的目标；</p> <ul><li><p><strong>扁平化嵌套</strong>: 首先，我们一定能想到组合函数最简单的操作就是 包裹，因为在 JS 中，函数也可以当做参数:</p> <ul><li><code>f(g(k(x)))</code>: 嵌套地狱，可读性低，当函数复杂后，容易让人一脸懵逼；</li> <li>理想的做法: <code>xxx(f, g, k)(x)</code></li></ul></li> <li><p><strong>结果传递</strong>: 如果想实现上面的方式，那也就是 <code>xxx</code> 函数要实现的便是: 执行结果在各个函数之间的执行传递；</p> <ul><li>这时我们就能想到一个原生提供的数组方法: <code>reduce</code>，它可以按数组的顺序依次执行，传递执行结果；</li> <li>所以我们就能够实现一个方法 <code>pipe</code>，用于函数组合:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ...fs: 将函数组合成数组；</span>
<span class="token comment">// Array.prototype.reduce 进行组合；</span>
<span class="token comment">// p: 初始参数；</span>
<span class="token keyword">const</span> <span class="token function-variable function">pipe</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>fs</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> fs<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
</code></pre></div></li> <li><p><strong>使用</strong>: 实现一个 驼峰命名 转 中划线命名 的功能:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 'Guo DongDong' --&gt; 'guo-dongdong'</span>
<span class="token comment">// 函数组合式写法</span>
<span class="token keyword">const</span> <span class="token function-variable function">toLowerCase</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> str<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> join <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">str<span class="token punctuation">,</span> arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> split <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">splitOn<span class="token punctuation">,</span> str</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>splitOn<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> toSlug <span class="token operator">=</span> <span class="token function">pipe</span><span class="token punctuation">(</span>
  toLowerCase<span class="token punctuation">,</span>
  <span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  encodeURIComponent
<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toSlug</span><span class="token punctuation">(</span><span class="token string">'Guo DongDong'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p><strong>好处:</strong></p> <ul><li>隐藏中间参数，不需要临时变量，避免了这个环节的出错几率；</li> <li>只需关注每个纯函数单元的稳定，不再需要关注命名，传递，调用等；</li> <li>可复用性强，任何一个函数单元都可被任意复用和组合；</li> <li>可拓展性强，成本低，例如现在加个需求，要查看每个环节的输出:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> log <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">label<span class="token punctuation">,</span> x</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>label<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> x
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> toSlug <span class="token operator">=</span> <span class="token function">pipe</span><span class="token punctuation">(</span>
  toLowerCase<span class="token punctuation">,</span>
  <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'toLowerCase output'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'split output'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'join output'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  encodeURIComponent
<span class="token punctuation">)</span>
</code></pre></div></li> <li><p><strong>数据不可变性</strong>(immutable): 这是一种数据理念，也是函数式编程中的核心理念之一:</p> <ul><li><strong>倡导</strong>: 一个对象再被创建后便不会再被修改。当需要改变值时，是返回一个全新的对象，而不是直接在原对象上修改；</li> <li><strong>目的</strong>: 保证数据的稳定性。避免依赖的数据被未知地修改，导致了自身的执行异常，能有效提高可控性与稳定性；</li> <li>并不等同于 <code>const</code> 。使用 const 创建一个对象后，它的属性仍然可以被修改；</li> <li>更类似于 <code>Object.freeze</code> : 冻结对象，但 <code>freeze</code> 仍无法保证深层的属性不被串改；</li> <li><code>immutable.js</code>: js 中的数据不可变库，它保证了数据不可变，在 React 生态中被广泛应用，大大提升了性能与稳定性；</li></ul></li> <li><p>避免不同函数之间的 <strong>状态共享</strong>，数据的传递使用复制或全新对象，遵守数据不可变原则；</p></li> <li><p>避免从函数内部 <strong>改变外部状态</strong>，例如改变了全局作用域或父级作用域上的变量值，可能会导致其它单位错误；</p></li> <li><p>避免在单元函数内部执行一些 <strong>副作用</strong>，应该将这些操作抽离成更独立的工具单元；</p> <ul><li>日志输出</li> <li>读写文件</li> <li>网络请求</li> <li>调用外部进程</li> <li>调用有副作用的函数</li></ul></li></ul></li></ul></li> <li><p><strong>高阶函数</strong>: 是指 以函数为参数，返回一个新的增强函数 的一类函数，它通常用于:</p> <ul><li>将逻辑行为进行 <strong>隔离抽象</strong>，便于快速复用，如处理数据，兼容性等；</li> <li><strong>函数组合</strong>，将一系列单元函数列表组合成功能更强大的函数；</li> <li><strong>函数增强</strong>，快速地拓展函数功能，</li></ul></li> <li><p><strong>函数式编程的好处:</strong></p> <ul><li>函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；</li> <li>不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提高稳定性与健壮性；</li> <li>追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；</li> <li>更易于做单元测试。</li></ul></li> <li><p><strong>总结:</strong></p> <ul><li>函数式编程其实是一种编程思想，它追求更细的粒度，将应用拆分成一组组极小的单元函数，组合调用操作数据流；</li> <li>它提倡着 纯函数 / 函数复合 / 数据不可变， 谨慎对待函数内的 状态共享 / 依赖外部 / 副作用；</li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">11/18/2022, 5:42:50 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/summary/framework/vue.html" class="prev">
        Vue
      </a></span> <span class="next"><a href="/summary/framework/Hybrid.html">
        Hybrid
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.07d4e7d8.js" defer></script><script src="/assets/js/2.e756895e.js" defer></script><script src="/assets/js/27.8165f251.js" defer></script>
  </body>
</html>
