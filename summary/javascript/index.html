<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原型/构造函数/实例 | 全明笔记</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/logo.png">
    <meta name="description" content="张全明的个人笔记">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.484694f3.css" as="style"><link rel="preload" href="/assets/js/app.07d4e7d8.js" as="script"><link rel="preload" href="/assets/js/2.e756895e.js" as="script"><link rel="preload" href="/assets/js/31.00125d26.js" as="script"><link rel="prefetch" href="/assets/js/10.9dcd3981.js"><link rel="prefetch" href="/assets/js/11.7c3a4891.js"><link rel="prefetch" href="/assets/js/12.9123d821.js"><link rel="prefetch" href="/assets/js/13.dc2b3bbc.js"><link rel="prefetch" href="/assets/js/14.8e9572dd.js"><link rel="prefetch" href="/assets/js/15.0831d9fb.js"><link rel="prefetch" href="/assets/js/16.fff0091e.js"><link rel="prefetch" href="/assets/js/17.13d701e1.js"><link rel="prefetch" href="/assets/js/18.c01d73d7.js"><link rel="prefetch" href="/assets/js/19.6d8da221.js"><link rel="prefetch" href="/assets/js/20.7e3bfbe7.js"><link rel="prefetch" href="/assets/js/21.d67b0029.js"><link rel="prefetch" href="/assets/js/22.a1d1221b.js"><link rel="prefetch" href="/assets/js/23.97f7c972.js"><link rel="prefetch" href="/assets/js/24.f25bbb61.js"><link rel="prefetch" href="/assets/js/25.886c2813.js"><link rel="prefetch" href="/assets/js/26.d354a60e.js"><link rel="prefetch" href="/assets/js/27.8165f251.js"><link rel="prefetch" href="/assets/js/28.38db902f.js"><link rel="prefetch" href="/assets/js/29.d089321c.js"><link rel="prefetch" href="/assets/js/3.c090ecd3.js"><link rel="prefetch" href="/assets/js/30.7f597fdf.js"><link rel="prefetch" href="/assets/js/32.1b584e55.js"><link rel="prefetch" href="/assets/js/33.b6331f3f.js"><link rel="prefetch" href="/assets/js/34.021e8dad.js"><link rel="prefetch" href="/assets/js/35.2b1e189b.js"><link rel="prefetch" href="/assets/js/36.4643cf1b.js"><link rel="prefetch" href="/assets/js/37.ff936690.js"><link rel="prefetch" href="/assets/js/4.55092137.js"><link rel="prefetch" href="/assets/js/5.02018b5a.js"><link rel="prefetch" href="/assets/js/6.bd7b0c2a.js"><link rel="prefetch" href="/assets/js/7.711e75c5.js"><link rel="prefetch" href="/assets/js/8.35b709e8.js"><link rel="prefetch" href="/assets/js/9.029996af.js">
    <link rel="stylesheet" href="/assets/css/0.styles.484694f3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">全明笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/summary/" class="nav-link router-link-active">
  知识总结
</a></div><div class="nav-item"><a href="/utils/" class="nav-link">
  工具类
</a></div><div class="nav-item"><a href="/links/" class="nav-link">
  学习资料
</a></div><div class="nav-item"><a href="/code/" class="nav-link">
  手写代码
</a></div><div class="nav-item"><a href="https://www.mingme.net/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/zhangquanming/docs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/summary/" class="nav-link router-link-active">
  知识总结
</a></div><div class="nav-item"><a href="/utils/" class="nav-link">
  工具类
</a></div><div class="nav-item"><a href="/links/" class="nav-link">
  学习资料
</a></div><div class="nav-item"><a href="/code/" class="nav-link">
  手写代码
</a></div><div class="nav-item"><a href="https://www.mingme.net/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/zhangquanming/docs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>知识总结</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/" aria-current="page" class="sidebar-link">前言</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/css/base.html" class="sidebar-link">CSS基础知识</a></li><li><a href="/summary/css/layout.html" class="sidebar-link">常见布局方式</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript 相关</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/javascript/" aria-current="page" class="active sidebar-link">JavaScript基础知识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/summary/javascript/#原型-构造函数-实例" class="sidebar-link">原型/构造函数/实例</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#执行上下文" class="sidebar-link">执行上下文</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#作用域" class="sidebar-link">作用域</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#作用域链" class="sidebar-link">作用域链</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#script-引入方式" class="sidebar-link">script 引入方式</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#对象的拷贝" class="sidebar-link">对象的拷贝</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#new-运算符的执行过程" class="sidebar-link">new 运算符的执行过程</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#instanceof-原理" class="sidebar-link">instanceof 原理</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#代码的复用" class="sidebar-link">代码的复用</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#类型转换" class="sidebar-link">类型转换</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#类型判断" class="sidebar-link">类型判断</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/summary/javascript/#typeof" class="sidebar-link">typeof</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#instanceof" class="sidebar-link">instanceof</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#object-prototype-tostring-call" class="sidebar-link">Object.prototype.toString.call()</a></li></ul></li><li class="sidebar-sub-header"><a href="/summary/javascript/#模块化" class="sidebar-link">模块化</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#防抖与节流" class="sidebar-link">防抖与节流</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#函数执行改变-this" class="sidebar-link">函数执行改变 this</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#es6-es7" class="sidebar-link">ES6/ES7</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#ast" class="sidebar-link">AST</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#babel-编译原理" class="sidebar-link">babel 编译原理</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#函数柯里化" class="sidebar-link">函数柯里化</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#数组-array-常用方法" class="sidebar-link">数组(Array) 常用方法</a></li><li class="sidebar-sub-header"><a href="/summary/javascript/#类数组转换数组" class="sidebar-link">类数组转换数组</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器与网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/http/web.html" class="sidebar-link">浏览器</a></li><li><a href="/summary/http/service.html" class="sidebar-link">服务端与网络</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端框架</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/framework/vue.html" class="sidebar-link">Vue</a></li><li><a href="/summary/framework/react.html" class="sidebar-link">React</a></li><li><a href="/summary/framework/Hybrid.html" class="sidebar-link">Hybrid</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>构建工具</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/bundler/webpack.html" class="sidebar-link">Webpack</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/monitor/monitor.html" class="sidebar-link">前端监控</a></li><li><a href="/summary/performance/performance.html" class="sidebar-link">项目性能优化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>全栈基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/summary/other/node.html" class="sidebar-link">Node</a></li><li><a href="/summary/other/nginx.html" class="sidebar-link">Nginx</a></li><li><a href="/summary/other/docker.html" class="sidebar-link">Docker</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="原型-构造函数-实例"><a href="#原型-构造函数-实例" class="header-anchor">#</a> 原型/构造函数/实例</h2> <ul><li>原型 <code>(prototype)</code>: 一个简单的对象，用于实现对象的<strong>属性继承</strong>。在 Firefox 和 Chrome 中，每个 JavaScript 对象中都包含一个 <code>__proto__</code> (非标准)的属性指向它父类(该对象的原型)，可通过 <code>obj.__proto__</code> 进行访问。</li> <li>构造函数: 可以通过 <code>new</code> 来<strong>新建一个对象</strong>的函数。</li> <li>实例: 通过构造函数和 <code>new</code> 创建出来的对象，便是实例。 实例通过 <code>__proto__</code> 指向原型，通过 <code>constructor</code> 指向构造函数。</li></ul> <img src="/assets/prototype_1.png" alt="执行上下文的组成"> <h2 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h2> <p>原型链是由原型对象组成，每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型，<code>__proto__</code> 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。</p> <ul><li><strong>属性查找机制</strong>: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象 <code>Object.prototype</code>，如还是没找到，则输出 <code>undefined</code>；</li> <li><strong>属性修改机制</strong>: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: <code>b.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</li></ul> <h2 id="执行上下文"><a href="#执行上下文" class="header-anchor">#</a> 执行上下文</h2> <p>执行上下文：指当前执行环境中的变量、函数声明，参数（arguments），作用域链，this 等信息。</p> <h4 id="上下文类型"><a href="#上下文类型" class="header-anchor">#</a> 上下文类型</h4> <ul><li>全局执行上下文</li> <li>函数执行上下文</li> <li><code>eval</code> 执行上下文</li></ul> <h4 id="上下文组成"><a href="#上下文组成" class="header-anchor">#</a> 上下文组成</h4> <ul><li>变量对象(VO)</li> <li>作用域链(词法作用域)</li> <li><code>this</code> 指向
<img src="/assets/ec_1.png" alt="执行上下文的组成"></li></ul> <h4 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h4> <ul><li><strong>创建阶段</strong> <ul><li>生成变量对象
<ul><li>创建 arguments</li> <li>函数声明</li> <li>变量声明</li></ul></li> <li>建立作用域链</li> <li>确定 this 的指向</li></ul></li> <li><strong>执行阶段</strong> <ul><li>变量赋值</li> <li>函数的引用</li> <li>执行其他代码</li></ul></li></ul> <img src="/assets/ec_2.jpg" alt="执行上下文生命周期："> <h4 id="变量对象"><a href="#变量对象" class="header-anchor">#</a> 变量对象</h4> <p>变量对象，是执行上下文中的一部分，可以抽象为一种<strong>数据作用域</strong>，它存储着该执行上下文中的所有 <strong>变量和函数声明(不包含函数表达式)</strong> 。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>活动对象 (AO): 当变量对象所处的上下文为 active EC 时，称为活动对象。</p></div> <h4 id="执行过程"><a href="#执行过程" class="header-anchor">#</a> 执行过程</h4> <ul><li>创建 <strong>全局上下文</strong> (global EC)。</li> <li>全局执行上下文 (caller) 逐行<strong>自上而下</strong>执行。遇到函数时，<strong>函数执行上下文</strong> (callee) 被 <code>push</code> 到执行栈顶层。</li> <li>函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起。</li> <li>函数执行完后，callee 被 <code>pop</code> 移除出执行栈，控制权交还全局上下文 (caller)，继续执行。</li></ul> <h2 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h2> <p>执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 <strong>变量和声明的作用范围</strong>。可分为 <strong>块级作用域</strong> 和 <strong>函数作用域</strong>。</p> <h4 id="特性"><a href="#特性" class="header-anchor">#</a> 特性:</h4> <ul><li><strong>声明提前</strong>: 一个声明在函数体内都是可见的, 函数优先于变量。</li> <li>非匿名自执行函数，函数变量为 <strong>只读</strong> 状态，无法修改。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  foo <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment">// 由于foo在函数中只为可读，因此赋值无效</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 结果打印：  ƒ foo() { foo = 10 ; console.log(foo) }</span>
</code></pre></div><h2 id="作用域链"><a href="#作用域链" class="header-anchor">#</a> 作用域链</h2> <p>在执行上下文中访问到父级甚至全局的变量，这便是作用域链的作用。作用域链可以理解为一组对象列表，包含<strong>父级和自身的变量对象</strong>，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p> <ul><li>由两部分组成:
<ul><li><code>[[scope]]</code> 属性: 指向父级变量对象和作用域链，也就是包含了父级的 <code>[[scope]]</code> 和 <code>AO</code>。</li> <li><code>AO</code>: 自身活动对象</li></ul></li></ul> <p>因此 <code>[[scopr]]</code> 包含 <code>[[scope]]</code>，便自上而下形成一条<strong>链式作用域</strong>。</p> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <h4 id="什么是闭包"><a href="#什么是闭包" class="header-anchor">#</a> 什么是闭包？</h4> <p>闭包是指有权访问另一个函数作用域中的变量的函数。</p> <h4 id="闭包原理"><a href="#闭包原理" class="header-anchor">#</a> 闭包原理</h4> <p>利用了函数作用域的特性，一个函数内部定义的函数会将外部函数的活动对象添加到他的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在应用这个活动对象，所以其活动对象不会被销毁。只有内部函数被销毁时才被销毁。</p> <h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <ul><li>可以从内部函数访问外部函数作用域中的变量，且访问的变量长期驻扎在内存中，可供之后使用</li> <li>避免变量污染全局</li> <li>把变量存在独立的作用域，作为私有成员存在</li></ul> <h4 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h4> <ul><li>因长驻内存中，对内存有消耗。使用不当会导致内存泄漏</li> <li>对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度</li></ul> <h4 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h4> <ul><li>模块封装，在各模块规范出现之前，都是用这样的方式防止变量污染全局。</li> <li>在循环中创建闭包，防止取到意外的值。</li> <li>闭包的应用场景非常多，只要用到了函数柯里化的地方就有闭包的身影，比如防抖节流、定时器、惰性处理等</li></ul> <h2 id="script-引入方式"><a href="#script-引入方式" class="header-anchor">#</a> script 引入方式</h2> <ul><li>html 静态 <code>&lt;script&gt;</code> 引入。</li> <li>js 动态插入 <code>&lt;script&gt;</code> 。</li> <li><code>&lt;script defer&gt;</code> : 延迟加载，元素解析完成后执行。</li> <li><code>&lt;script async&gt;</code> : 异步加载，但执行时会阻塞元素渲染。</li></ul> <h2 id="对象的拷贝"><a href="#对象的拷贝" class="header-anchor">#</a> 对象的拷贝</h2> <ul><li><p>浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，<strong>修改时原对象也会受到影响</strong>。</p> <ul><li><code>Object.assign</code></li> <li>展开运算符(...)</li></ul></li> <li><p>深拷贝: 完全拷贝一个新对象，<strong>修改时原对象不再受到任何影响</strong>。</p> <ul><li>JSON.parse(JSON.stringify(obj)): 性能最快。
<ul><li>具有循环引用的对象时，报错。</li> <li>当值为函数、undefined、或 symbol 时，无法拷贝。</li></ul></li> <li>递归进行逐一赋值。</li></ul></li></ul> <h2 id="new-运算符的执行过程"><a href="#new-运算符的执行过程" class="header-anchor">#</a> new 运算符的执行过程</h2> <ul><li>新生成一个对象。</li> <li>链接到原型: <code>obj.__proto__ = Con.prototype</code>。</li> <li>绑定 <code>this</code>: <code>apply</code>。</li> <li>返回新对象(如果构造函数有自己 retrun 时，则返回该值)。</li></ul> <h2 id="instanceof-原理"><a href="#instanceof-原理" class="header-anchor">#</a> instanceof 原理</h2> <p>能在实例的 <strong>原型对象链</strong> 中找到该构造函数的 <code>prototype</code> 属性所指向的 <strong>原型对象</strong>，就返回 true。</p> <p>即:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// __proto__: 代表原型对象链</span>
instance<span class="token punctuation">.</span><span class="token punctuation">[</span>__proto__<span class="token operator">...</span><span class="token punctuation">]</span> <span class="token operator">===</span> instance<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>prototype

<span class="token comment">// return true</span>
</code></pre></div><h2 id="代码的复用"><a href="#代码的复用" class="header-anchor">#</a> 代码的复用</h2> <p>当你发现任何代码开始写第二遍时，就要开始考虑如何复用。一般有以下的方式:</p> <ul><li>函数封装</li> <li>继承</li> <li>复制 <code>extend</code></li> <li>混入 <code>mixin</code></li> <li>借用 <code>apply/call</code></li></ul> <h2 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h2> <p>在 JS 中，继承通常指的便是 <strong>原型链继承</strong>，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。</p> <ul><li>原型链继承：内存空间是共享的，实例之间相互影响。</li> <li>构造函数继承：无法复用父类原型属性和方法，缺少复用性。</li> <li>组合是继承：共享父类原型方法与属性，但是调用两次构造函数。</li> <li>原型式继承：子类构建时无法向父类传参，私有引用属性共享。</li> <li>寄生式继承： 原型式继承加强版，缺点类同。</li> <li>寄生组合式：集各模式所长, 总体来说就是解决了 组合模式 两次调用父类构造方法的弊端，减少子类父类属性 重复的问题，减少了内存占用。</li> <li>最优化：圣杯模式</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> inherit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">c<span class="token punctuation">,</span> p</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">c<span class="token punctuation">,</span> p</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> p<span class="token punctuation">.</span>prototype
    c<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    c<span class="token punctuation">.</span>uber <span class="token operator">=</span> p<span class="token punctuation">.</span>prototype
    c<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> c
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>使用 ES6 的语法糖 <code>class / extends</code></li></ul> <h2 id="类型转换"><a href="#类型转换" class="header-anchor">#</a> 类型转换</h2> <p>JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:</p> <ul><li>-、*、/、% ：一律转换成数值后计算</li> <li>+：
<ul><li>数字 + 字符串 = 字符串， 运算顺序是从左到右</li> <li>数字 + 对象， 优先调用对象的 <code>valueOf</code> -&gt; <code>toString</code></li> <li>数字 + <code>boolean/null</code> -&gt; 数字</li> <li>数字 + <code>undefined</code> -&gt; <code>NaN</code></li></ul></li> <li><code>[1].toString() === '1'</code></li> <li><code>{}.toString() === '[object object]'</code></li> <li><code>NaN !== NaN</code> 、<code>+undefined</code> 为 <code>NaN</code></li></ul> <h2 id="类型判断"><a href="#类型判断" class="header-anchor">#</a> 类型判断</h2> <p>判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</p> <ul><li>基本类型(<code>null</code>): 使用 <code>String(null)</code>。</li> <li>基本类型(<code>string / number / boolean / undefined</code>) + <code>function</code>: 直接使用 <code>typeof</code> 即可。</li> <li>其余引用类型(<code>Array / Date / RegExp Error</code>): 调用 <code>toString</code> 后根据 <code>[object XXX]</code> 进行判断。</li></ul> <h3 id="typeof"><a href="#typeof" class="header-anchor">#</a> typeof</h3> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// number</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// boolean</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">'mc'</span><span class="token punctuation">)</span> <span class="token comment">// string</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Symbol<span class="token punctuation">)</span> <span class="token comment">// function</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// function</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>
</code></pre></div><p>优点：能够快速区分基本数据类型</p> <p>缺点：不能将 Object、Array 和 Null 区分，都返回 object</p> <h3 id="instanceof"><a href="#instanceof" class="header-anchor">#</a> instanceof</h3> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token keyword">instanceof</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'str'</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre></div><p>优点：能够区分 Array、Object 和 Function，适合用于判断自定义的类实例对象</p> <p>缺点：Number，Boolean，String 基本数据类型不能判断</p> <h3 id="object-prototype-tostring-call"><a href="#object-prototype-tostring-call" class="header-anchor">#</a> Object.prototype.toString.call()</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> toString <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//[object Number]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//[object Boolean]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'mc'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//[object String]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//[object Array]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//[object Object]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//[object Function]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//[object Undefined]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//[object Null]</span>
</code></pre></div><p>优点：精准判断数据类型</p> <p>缺点：写法繁琐不容易记，推荐进行封装后使用</p> <p>很稳的判断封装:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> class2type <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token string">'Array Date RegExp Object Error'</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>class2type<span class="token punctuation">[</span><span class="token string">'[object '</span> <span class="token operator">+</span> e <span class="token operator">+</span> <span class="token string">']'</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">type</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">String</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">?</span> class2type<span class="token punctuation">[</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token string">'object'</span> <span class="token operator">:</span> <span class="token keyword">typeof</span> obj
<span class="token punctuation">}</span>
</code></pre></div><h2 id="模块化"><a href="#模块化" class="header-anchor">#</a> 模块化</h2> <p>模块化开发在现代开发中已是必不可少的一部分，它大大提高了项目的可维护、可拓展和可协作性。通常，我们 <strong>在浏览器中使用 ES6 的模块化支持，在 Node 中使用 commonjs 的模块化支持</strong>。</p> <ul><li><p>分类:</p> <ul><li>es6: <code>import / export</code></li> <li>commonjs: <code>require / module.exports / exports</code></li> <li>amd: <code>require / defined</code>(依赖前置)</li> <li>cmd: (依赖就近)</li></ul></li> <li><p><code>require</code> 与 <code>import</code> 的区别:</p> <ul><li><code>require</code> 支持 动态导入，<code>import</code> 不支持，正在提案 (babel 下可支持)。</li> <li><code>require</code> 是 同步 导入，<code>import</code> 属于 <strong>异步</strong> 导入。</li> <li><code>require</code> 是 <strong>值拷贝</strong>，导出值变化不会影响导入值；<code>import</code> 指向 <strong>内存地址</strong>，导入值会随导出值而变化。</li></ul></li></ul> <h2 id="防抖与节流"><a href="#防抖与节流" class="header-anchor">#</a> 防抖与节流</h2> <p>防抖与节流函数是一种最常用的 <strong>高频触发优化方式</strong>，能对性能有较大的帮助。</p> <ul><li><strong>防抖 (debounce)</strong>: 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> args <span class="token operator">=</span> arguments
    <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><strong>节流(throttle)</strong>: 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms 执行一次即可。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">let</span> callNow <span class="token operator">=</span> immediate

  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span>
      args <span class="token operator">=</span> arguments

    <span class="token keyword">if</span> <span class="token punctuation">(</span>callNow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
      callNow <span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="函数执行改变-this"><a href="#函数执行改变-this" class="header-anchor">#</a> 函数执行改变 this</h2> <p>由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是 <code>this</code>。</p> <p>要明白 <code>this</code> 指向，其实就是要搞清楚 函数的运行环境，实际就是谁调用了函数。例如:</p> <ul><li><code>obj.fn()</code>，便是 <code>obj</code> 调用了函数，既函数中的 <code>this === obj</code></li> <li><code>fn()</code>，这里可以看成 <code>window.fn()</code>，因此 <code>this === window</code></li></ul> <p>但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 <code>this</code> 的指向:</p> <ul><li><code>call: fn.call(target, 1, 2)</code></li> <li><code>apply: fn.apply(target, [1, 2])</code></li> <li><code>bind: fn.bind(target)(1,2)</code></li></ul> <h2 id="es6-es7"><a href="#es6-es7" class="header-anchor">#</a> ES6/ES7</h2> <p>由于 Babel 的强大和普及，现在 ES6/ES7 基本上已经是现代化开发的必备了。通过新的语法糖，能让代码整体更为简洁和易读。</p> <ul><li>声明
<ul><li><code>let / const</code>: 块级作用域、不存在变量提升、暂时性死区、不允许重复声明</li> <li><code>const</code>: 声明常量，无法修改</li></ul></li> <li>解构赋值</li> <li><code>class / extend</code>: 类声明与继承</li> <li><code>Set / Map</code>: 新的数据结构</li> <li>异步解决方案:
<ul><li><code>Promise</code> 的使用与实现</li> <li><code>generator</code> :
<ul><li>yield: 暂停代码</li> <li>next(): 继续执行代码</li></ul></li> <li><code>await / async</code>: 是 <code>generator</code> 的语法糖， babel 中是基于 <code>promise</code> 实现</li></ul></li></ul> <h2 id="ast"><a href="#ast" class="header-anchor">#</a> AST</h2> <p><strong>抽象语法树 (Abstract Syntax Tree)</strong>，是将代码逐字母解析成 <strong>树状对象</strong> 的形式。这是语言之间的转换、代码语法检查，代码风格检查，代码格式化，代码高亮，代码错误提示，代码自动补全等等的基础。</p> <h2 id="babel-编译原理"><a href="#babel-编译原理" class="header-anchor">#</a> babel 编译原理</h2> <p>Babel 是一个 JavaScript 编译器，是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p> <ul><li>babylon 将 ES6/ES7 代码解析成 AST</li> <li>babel-traverse 对 AST 进行遍历转译，得到新的 AST</li> <li>新 AST 通过 babel-generator 转换成 ES5</li></ul> <p><code>Babel</code> 的功能很纯粹，它只是一个编译器。大多数编译器的工作过程可以分为三部分：</p> <ul><li><strong>解析（Parse）</strong> ：将源代码转换成更加抽象的表示方法（例如抽象语法树）。包括词法分析和语法分析。词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树（Abstract Syntax Tree，AST）。</li> <li><strong>转换（Transform）</strong> ：通过 Babel 的插件能力，对（抽象语法树）做一些特殊处理，将高版本语法的 AST 转换成支持低版本语法的 AST。让它符合编译器的期望，当然在此过程中也可以对 AST 的 Node 节点进行优化操作，比如添加、更新以及移除节点等。</li> <li><strong>生成（Generate）</strong> ：将 AST 转换成字符串形式的低版本代码，同时也能创建 Source Map 映射。</li></ul> <h2 id="函数柯里化"><a href="#函数柯里化" class="header-anchor">#</a> 函数柯里化</h2> <p>在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 <strong>预置通用参数</strong>，供多次重复调用。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> add1 <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token function">add1</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">3</span>
<span class="token function">add1</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">21</span>
</code></pre></div><h2 id="数组-array-常用方法"><a href="#数组-array-常用方法" class="header-anchor">#</a> 数组(Array) 常用方法</h2> <ul><li><code>map</code> : 遍历数组，返回回调返回值组成的新数组</li> <li><code>forEach</code>: 无法 <code>break</code>，可以用 <code>try/catch</code> 中 <code>throw new Error</code> 来停止</li> <li><code>filter</code> : 过滤</li> <li><code>some</code>: 有一项返回 <code>true</code>，则整体为 <code>true</code></li> <li><code>every</code> : 有一项返回 <code>false</code>，则整体为 <code>false</code></li> <li><code>join</code> : 通过指定连接符生成字符串</li> <li><code>push / pop</code> : 末尾推入和弹出，改变原数组， <code>push</code> 返回数组长度, <code>pop</code> 返回原数组最后一项</li> <li><code>unshift / shift</code> : 头部推入和弹出，改变原数组，<code>unshift</code> 返回数组长度，<code>shift</code> 返回原数组第一项</li> <li><code>sort(fn) / reverse</code> : 排序与反转，改变原数组</li> <li><code>concat</code> : 连接数组，不影响原数组， 浅拷贝</li> <li><code>slice(start, end)</code> : 返回截断后的新数组，不改变原数组</li> <li><code>splice(start, number, value...)</code> : 返回删除元素组成的数组，<code>value</code> 为插入项，改变原数组</li> <li><code>indexOf / lastIndexOf(value, fromIndex)</code> : 查找数组项，返回对应的下标</li> <li><code>reduce / reduceRight(fn(prev, cur)， defaultPrev)</code> : 两两执行，<code>prev</code> 为上次化简函数的 <code>return</code> 值，<code>cur</code> 为当前值
<ul><li>当传入 <code>defaultPrev</code> 时，从第一项开始；</li> <li>当未传入时，则为第二项</li></ul></li> <li>数组乱序：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>
arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">0.5</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>数组扁平化: flat: <code>[1,[2,3]] --&gt; [1, 2, 3]</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">flat</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">+</span>item<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="类数组转换数组"><a href="#类数组转换数组" class="header-anchor">#</a> 类数组转换数组</h2> <ul><li>转换方法
<ul><li><code>Array.from()</code></li> <li><code>Array.prototype.slice.call()</code></li> <li><code>Array.prototype.forEach()</code> 进行属性遍历并组成新的数组</li></ul></li> <li>装换须知
<ul><li>转换后的数组长度由 length 属性决定。索引不连续时转换结果是连续的，会自动补位。</li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">3/3/2023, 6:48:32 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/summary/css/layout.html" class="prev">
        常见布局方式
      </a></span> <span class="next"><a href="/summary/http/web.html">
        浏览器
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.07d4e7d8.js" defer></script><script src="/assets/js/2.e756895e.js" defer></script><script src="/assets/js/31.00125d26.js" defer></script>
  </body>
</html>
